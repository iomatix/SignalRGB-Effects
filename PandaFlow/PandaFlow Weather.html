<!DOCTYPE html>
<html>

<head>
    <title>PandaFlow Weather BETA</title>
    <meta
        description="Breathing + Alternating Rain + Audio-Reactive (wip) + Scale + Presets + Drop Shapes - Refactored for SignalRGB" />
    <meta publisher="iomatix" />

    <meta property="globalSeed" label="Seed" type="number" min="10" max="999" step="1" default="614" />
    <!-- Presets (unchanged interface for SignalRGB) -->
    <meta property="preset" label="Weather Preset" type="list" default="Custom"
        values="Custom,Storm,Calm,Waves,Rain,Snow,Sandstorm,Pulsar,Pulsar2,Stars" />
    <meta property="presetIntensity" label="Preset Intensity (10=0.1, 100=1.0, 300=3.0)" type="number" min="10"
        max="999" step="1" default="100" />
    <!-- Visual extras -->
    <meta property="influenceWidth" label="Line Thickness (20=0.020)" type="number" min="5" max="999" step="1"
        default="20" />
    <meta property="useGradient" label="Use Gradient Along Drop" type="boolean" default="true" />
    <meta property="useBlink" label="Blink Drops" type="boolean" default="false" />
    <meta property="primaryRainBlinkPeriod" label="Primary Blink Period (s)" type="number" min="0" max="200" step="1"
        default="28" />
    <meta property="secondaryRainBlinkPeriod" label="Secondary Blink Period (s)" type="number" min="0" max="200"
        step="1" default="28" />
    <meta property="tertiaryRainBlinkPeriod" label="Tertiary Blink Period (s)" type="number" min="0" max="200" step="1"
        default="28" />
    <meta property="maxDrops" label="Max Drops Per Layer" type="number" min="50" max="999" step="1" default="500" />

    <meta property="stormLightningChance" label="Storm Lightning Chance (100=0.01 per frame)" type="number" min="0"
        max="1500" step="1" default="100" />
    <meta property="stormMicroGustChance" label="Storm Micro-Gust Chance (20=0.002 per frame)" type="number" min="0"
        max="550" step="1" default="20" />
    <meta property="sandstormGustBurstChance" label="Sandstorm Gust Burst Chance (30=0.003 per frame)" type="number"
        min="0" max="550" step="1" default="30" />
    <meta property="starShipSize" label="StarShip Size" type="number" min="1" max="99" step="1" default="14" />
    <meta property="meteorSize" label="Meteor Size" type="number" min="1" max="99" step="1" default="15" />
    <meta property="starsMeteorShowerChance" label="Stars Meteor Shower Chance (15=0.0015 per frame)" type="number"
        min="0" max="250" step="1" default="15" />
    <meta property="primaryMeteorCount" label="Primary Meteors Per Shower" type="number" min="0" max="50" step="1"
        default="3" />
    <meta property="secondaryMeteorCount" label="Secondary Meteors Per Shower" type="number" min="0" max="50" step="1"
        default="3" />
    <meta property="tertiaryMeteorCount" label="Tertiary Meteors Per Shower" type="number" min="0" max="50" step="1"
        default="3" />
    <meta property="meteorShowerBoost" label="Stars Meteor Speed Boost" type="number" min="1" max="10" step="1"
        default="3" />
    <meta property="staticStarLifespan" label="Static Star Lifespan (sec)" type="number" min="1" max="320" step="1"
        default="8" />
    <meta property="staticStarCount" label="Static Stars Count" type="number" min="1" max="999" step="1" default="50" />
    <meta property="staticStarSize" label="Static Star Size" type="number" min="1" max="99" step="1" default="2" />
    <meta property="staticStarColorSource" label="Static Stars Color Source" type="list" default="Custom"
        values="Theme,Primary,Secondary,Tertiary,Random,Custom" />
    <meta property="staticStarCustomColor" label="Custom Static Star Color" type="color" default="#FFFFFF" />
    <!-- Colors -->
    <meta property="themeColor" label="Theme / Background Color" type="color" default="#101014" />
    <!-- BG -->
    <meta property="usePicture" label="Picture Color Source" type="boolean" default="false" />
    <!-- Breathing -->
    <meta property="breathingColorSource" label="Breathing Color Source" type="list" default="Theme"
        values="Theme,Primary,Secondary,Tertiary,Random,Custom" />
    <meta property="breathingCustomColor" label="Custom Breathing Color" type="color" default="#FFFFFF" />
    <meta property="breathingCycleSec" label="Breathing Cycle Seconds (750=7.5s)" type="number" min="25" max="1500"
        step="5" default="200" />
    <meta property="breathingMin" label="Breathing Minimum Intensity (15=0.15)" type="number" min="0" max="100" step="1"
        default="15" />
    <meta property="breathingMax" label="Breathing Maximum Intensity (80=0.80)" type="number" min="0" max="100" step="1"
        default="95" />

    <!-- Audio-reactive -->
    <meta property="audioReactive" label="Audio Reactive (may cause issues if API not available)" type="boolean"
        default="false" />
    <meta property="audioSource" label="Audio Source" type="list" default="Microphone" values="Microphone,System" />
    <meta property="audioFloor" label="Audio Floor (5=0.05)" type="number" min="0" max="50" step="1" default="5" />
    <meta property="audioCeiling" label="Audio Ceiling (35=0.35)" type="number" min="5" max="100" step="1"
        default="35" />
    <meta property="audioSensitivity" label="Audio Sensitivity (100=1.0)" type="number" min="20" max="400" step="10"
        default="100" />
    <meta property="audioAttackMs" label="Audio Attack Milliseconds" type="number" min="1" max="200" step="1"
        default="30" />
    <meta property="audioReleaseMs" label="Audio Release Milliseconds" type="number" min="10" max="1000" step="10"
        default="180" />
    <meta property="audioMix" label="Audio Mix Blend (55=0.55)" type="number" min="0" max="100" step="1" default="55" />

    <!-- Canvas -->
    <meta property="objectScale" label="Objects scale on canvas (100=1.0)" type="number" min="25" max="999" step="1"
        default="100" />

    <!-- Drop -->
    <meta property="primaryShape" label="Primary Drop Shape" type="list" default="Line"
        values="Line,Dot,WaterDroplet,WaterDropletStorm,Sand,Snow,Meteor,Star,StarShip" />

    <meta property="secondaryShape" label="Secondary Drop Shape" type="list" default="Dot"
        values="Line,Dot,WaterDroplet,WaterDropletStorm,Sand,Snow,Meteor,Star,StarShip" />

    <meta property="tertiaryShape" label="Tertiary Drop Shape" type="list" default="Star"
        values="Line,Dot,WaterDroplet,WaterDropletStorm,Sand,Snow,Meteor,Star,StarShip" />

    <!-- Primary rain -->
    <meta property="primaryRainCount" label="Primary Drop Count" type="number" min="0" max="60" step="1" default="10" />
    <meta property="primaryRainSpeed" label="Primary Drop Speed" type="number" min="10" max="800" step="5"
        default="220" />
    <meta property="primaryRainLength" label="Primary Drop Length (20=0.20)" type="number" min="2" max="80" step="1"
        default="20" />
    <meta property="primaryRainSpacing" label="Primary Drop Spacing (18=0.18)" type="number" min="0" max="50" step="1"
        default="18" />
    <meta property="primaryRainAngle" label="Primary Drop Angle (degrees)" type="number" min="0" max="360" step="1"
        default="90" />
    <meta property="primaryColor" label="Primary Drop Color" type="color" default="#00B3B3" />

    <!-- Secondary rain -->
    <meta property="secondaryRainCount" label="Secondary Drop Count" type="number" min="0" max="60" step="1"
        default="10" />
    <meta property="secondaryRainSpeed" label="Secondary Drop Speed" type="number" min="10" max="800" step="5"
        default="240" />
    <meta property="secondaryRainLength" label="Secondary Drop Length (12=0.12)" type="number" min="2" max="80" step="1"
        default="12" />
    <meta property="secondaryRainSpacing" label="Secondary Drop Spacing (14=0.14)" type="number" min="0" max="50"
        step="1" default="14" />
    <meta property="secondaryRainAngle" label="Secondary Drop Angle (degrees)" type="number" min="0" max="360" step="1"
        default="60" />
    <meta property="secondaryColor" label="Secondary Drop Color" type="color" default="#E6F6FF" />

    <!-- Tertiary rain -->
    <meta property="tertiaryRainCount" label="Tertiary Drop Count" type="number" min="0" max="60" step="1"
        default="10" />
    <meta property="tertiaryRainSpeed" label="Tertiary Drop Speed" type="number" min="10" max="800" step="5"
        default="200" />
    <meta property="tertiaryRainLength" label="Tertiary Drop Length (20=0.20)" type="number" min="2" max="80" step="1"
        default="15" />
    <meta property="tertiaryRainSpacing" label="Tertiary Drop Spacing (18=0.18)" type="number" min="0" max="50" step="1"
        default="18" />
    <meta property="tertiaryRainAngle" label="Tertiary Drop Angle (degrees)" type="number" min="0" max="360" step="1"
        default="120" />
    <meta property="tertiaryColor" label="Tertiary Drop Color" type="color" default="#FFD966" />


    <style>
        html,
        body {
            height: 100%;
            margin: 0
        }

        canvas {
            display: block
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="320" height="200"></canvas>

    <script>
        /*
         * PandaFlow Weather - professional refactor for SignalRGB
         * - Central SettingsManager that caches values from <meta> + window
         * - Polling for panel/host changes (SignalRGB sets window.*), but we only
         *   apply those changes when they actually occur (no blind per-frame overwrites)
         * - Presets apply once on change and write to both cache and window so the panel sees them
         * - All runtime code reads from settings.get(...) to avoid race conditions
         *
         * Based on SignalRGB docs: meta tags create controls and supply values via window[property].
         */

        'use strict';

        // ---------- Utilities ----------

        // Minimal inline SHA-1 (no imports, no WebCrypto)
        function sha1ArrayBuffer(arrayBuffer) {
            const data = new Uint8Array(arrayBuffer);
            let i, j, t;
            const l = ((data.length + 8) >>> 6 << 4) + 16;
            const s = new Uint8Array(l << 2);
            s.set(data);
            const view = new DataView(s.buffer);
            view.setUint32((data.length << 3) >>> 29, 0, false); // high bits
            view.setUint32((l << 2) - 4, (data.length << 3) & 0xffffffff, false); // low bits

            const w = new Uint32Array(80);
            let h0 = 0x67452301, h1 = 0xEFCDAB89, h2 = 0x98BADCFE, h3 = 0x10325476, h4 = 0xC3D2E1F0;

            for (i = 0; i < s.length; i += 64) {
                const base = i;
                for (j = 0; j < 16; j++) w[j] = view.getUint32(base + j * 4);
                for (j = 16; j < 80; j++) {
                    t = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
                    w[j] = (t << 1) | (t >>> 31);
                }
                let a = h0, b = h1, c = h2, d = h3, e = h4;
                for (j = 0; j < 80; j++) {
                    const f = j < 20 ? (b & c) | (~b & d)
                        : j < 40 ? b ^ c ^ d
                            : j < 60 ? (b & c) | (b & d) | (c & d)
                                : b ^ c ^ d;
                    const k = j < 20 ? 0x5A827999
                        : j < 40 ? 0x6ED9EBA1
                            : j < 60 ? 0x8F1BBCDC
                                : 0xCA62C1D6;
                    t = (((a << 5) | (a >>> 27)) + f + e + k + w[j]) >>> 0;
                    e = d;
                    d = c;
                    c = (b << 30) | (b >>> 2);
                    b = a;
                    a = t;
                }
                h0 = (h0 + a) >>> 0;
                h1 = (h1 + b) >>> 0;
                h2 = (h2 + c) >>> 0;
                h3 = (h3 + d) >>> 0;
                h4 = (h4 + e) >>> 0;
            }
            return [h0, h1, h2, h3, h4].map(h => ('00000000' + h.toString(16)).slice(-8)).join('');
        }


        function nowSec() { return Date.now() / 1000; }
        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        function mix(a, b, t) { return a + (b - a) * t; }
        function deg2rad(d) { return d * Math.PI / 180; }
        function rad2deg(r) { return r * 180 / Math.PI; }

        function hexToRgb(hex) {
            if (!hex) return [0, 0, 0];
            hex = ('' + hex).replace('#', '');
            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
            const r = parseInt(hex.slice(0, 2), 16) || 0;
            const g = parseInt(hex.slice(2, 4), 16) || 0;
            const b = parseInt(hex.slice(4, 6), 16) || 0;
            return [r, g, b];
        }

        // Helper to scale a base value with preset intensity
        // mode: 'linear' (default) or 'range'
        // For 'linear', value is multiplied by intensity
        // For 'range', value is interpolated between min and max based on intensity
        // For 'log', value is multiplied first and then log is applied.
        function scaleWithIntensity(baseValue, intensity, mode = 'linear', minFactor = 0.5, maxFactor = 1.5) {
            if (mode === 'linear') {
                return baseValue * intensity;
            } else if (mode === 'range') {
                return baseValue * (minFactor + (maxFactor - minFactor) * intensity);
            }
            else if (mode === 'log') {
                1 + Math.log(baseValue * intensity) / Math.log(2)
            }
            return baseValue;
        }

        // Helper to scale counts safely with intensity
        function scaleCount(baseCount, intensity, minFactor = 0.5, maxFactor = 2.0) {
            const f = minFactor + (maxFactor - minFactor) * clamp(intensity, 0, 3); // supports 0.1..3.0 UI range
            return Math.max(0, Math.round(baseCount * f));
        }

        function scaleBlur(blurBase, canvas) {
            const shorterSide = Math.min(canvas.width, canvas.height);
            const longerSide = Math.max(canvas.width, canvas.height);
            return blurBase * (shorterSide / longerSide);
        }

        // Small LCG for stable per-drop randomness
        function seeded(seed) {
            let s = Math.floor((seed + globalSeed) * 1e9) || 1;
            return function () {
                s = (1664525 * s + 1013904223) % 4294967296;
                return (s >>> 0) / 4294967296;
            };
        }

        // Add a cooldown tracker
        let lastBackgroundFetch = 0;
        const BACKGROUND_FETCH_INTERVAL = 30 * 1000; // 30 seconds

        function maybePreloadBackground(callback, fileSrc) {
            const now = Date.now();
            if (now - lastBackgroundFetch >= BACKGROUND_FETCH_INTERVAL) {
                lastBackgroundFetch = now;
                preloadBackground(callback, fileSrc);
            } else if (cachedImage) {
                // Use the cached image without fetching
                callback(cachedImage);
            }
        }

        let cachedImage = null;
        let cachedHash = null;
        let lastCheck = 0;
        const CHECK_INTERVAL = 2000;
        async function preloadBackground(
            callback,
            fileSrc = 'https://raw.githubusercontent.com/iomatix/SignalRGB-Effects/main/PandaFlow/pandaflow-weather-bg.png'
        ) {
            const now = Date.now();

            if (now - lastCheck < CHECK_INTERVAL && cachedImage) {
                console.log("[preloadBackground] Using cached image");
                callback(cachedImage);
                return;
            }
            lastCheck = now;

            try {
                console.log("[preloadBackground] Fetching:", fileSrc);
                const response = await fetch(`${fileSrc}?cacheBust=${now}`);
                console.log("[preloadBackground] Status:", response.status);

                if (!response.ok) throw new Error(`HTTP ${response.status} while fetching ${fileSrc}`);

                const blob = await response.blob();
                console.log("[preloadBackground] Blob size:", blob.size);

                const buffer = await blob.arrayBuffer();
                console.log("[preloadBackground] Buffer length:", buffer.byteLength);

                // Pure JS SHA-1
                let hashHex;
                try {
                    console.log("[preloadBackground] Hashing buffer (inline SHA-1)...");
                    hashHex = sha1ArrayBuffer(buffer);
                    console.log("[preloadBackground] Hash:", hashHex);
                } catch (hashErr) {
                    console.error("[preloadBackground] Hashing failed:", hashErr);
                    return;
                }

                if (hashHex !== cachedHash) {
                    console.log("[preloadBackground] New image detected, updating cache");
                    cachedHash = hashHex;

                    const img = new Image();
                    img.onload = () => {
                        console.log("[preloadBackground] Image loaded successfully");
                        try {
                            cachedImage = img;
                            callback(img);
                        } catch (cbErr) {
                            console.error("[preloadBackground] Callback failed:", cbErr);
                        }
                    };
                    img.onerror = (e) => {
                        console.error("[preloadBackground] Image failed to decode", e);
                        ctx.fillStyle = "#000";
                        ctx.fillRect(0, 0, W, H);
                    };
                    img.src = URL.createObjectURL(blob);
                } else if (cachedImage) {
                    console.log("[preloadBackground] Image unchanged, using cached version");
                    callback(cachedImage);
                }

            } catch (e) {
                const err = e instanceof Error ? e : new Error(String(e));
                console.group("[preloadBackground] ERROR");
                console.error("Message:", err.message);
                console.error("Stack:", err.stack || "No stack trace available");
                console.error("File source:", fileSrc);
                console.error("Timestamp:", new Date().toISOString());
                console.error("Cached hash:", cachedHash);
                console.error("Has cached image:", !!cachedImage);
                console.groupEnd();

                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, W, H);
            }
        }


        function getImageChecksum(img) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.naturalWidth;
            tempCanvas.height = img.naturalHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);

            const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;

            // Hash: Sum RGBA
            let checksum = 0;
            for (let i = 0; i < data.length; i++) {
                checksum += data[i];
            }
            return checksum;
        }

        function drawBackgroundImage(img) {
            ctx.save();
            const scale = Math.min(W / img.naturalWidth, H / img.naturalHeight);
            const scaledWidth = img.naturalWidth * scale;
            const scaledHeight = img.naturalHeight * scale;
            const x = (W - scaledWidth) / 2;
            const y = (H - scaledHeight) / 2;
            ctx.globalAlpha = 1;
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            ctx.restore();
        }

        function drawLogoAt(img, x, y, scale) {
            ctx.save();
            const scaledWidth = img.naturalWidth * scale;
            const scaledHeight = img.naturalHeight * scale;
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            ctx.restore();
        }

        function drawSplashLogos(img) {
            // Black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, W, H);

            const scale = 0.3; // logo scale relative to the original
            const logoW = img.naturalWidth * scale;
            const logoH = img.naturalHeight * scale;

            // Margin as a percentage of the canvas dimensions (e.g., 5%)
            const marginX = W * 0.05;
            const marginY = H * 0.05;

            const positions = [
                { x: marginX, y: marginY }, // top left
                { x: W - logoW - marginX, y: marginY }, // top right
                { x: marginX, y: H - logoH - marginY }, // bottom left
                { x: W - logoW - marginX, y: H - logoH - marginY }, // bottom right
                { x: (W - logoW) / 2, y: (H - logoH) / 2 } // center
            ];

            positions.forEach(pos => drawLogoAt(img, pos.x, pos.y, scale));
        }

        // ---------- SettingsManager ----------
        class SettingsManager {

            constructor() {
                this.keys = [];            // list of property names from meta
                this.live = {};            // cached values used by runtime
                this.lastWindow = {};      // last observed window value per key
                this.userModified = {};    // flags if the panel/user changed this value
                this.lockedParams = new Set();  // locks de-sync per prop in master (SignalRGB user panel)

                this.presetValues = {};   // remember preset-applied values
                this.overwrittenValue = {}; // values that were in panel before preset

                this._collectMetaDefaults();
            }

            _parseDefault(def) {
                if (def === null || typeof def === 'undefined') return undefined;
                if (def === 'true' || def === 'false') return (def === 'true');
                if (/^#?[0-9a-fA-F]{3}$/.test(def) || /^#?[0-9a-fA-F]{6}$/.test(def)) return def;
                if (!isNaN(parseFloat(def)) && isFinite(def)) return parseFloat(def);
                return def;
            }

            _collectMetaDefaults() {
                const metas = document.querySelectorAll('meta[property]');
                metas.forEach(m => {
                    const name = m.getAttribute('property');
                    if (!name) return;
                    if (this.keys.indexOf(name) === -1) this.keys.push(name);
                    const def = m.getAttribute('default');
                    const parsed = this._parseDefault(def);

                    // Prefer existing host-provided window[name] if present (SignalRGB may set it before script runs)
                    const hostVal = (typeof window[name] !== 'undefined') ? window[name] : undefined;
                    const initial = (typeof hostVal !== 'undefined') ? hostVal : parsed;

                    this.live[name] = initial;
                    this.lastWindow[name] = initial;
                    this.userModified[name] = false;

                    // make sure host sees something
                    try { window[name] = initial; } catch (e) { /* ignore */ }
                });

                // also ensure we manage some commonly-used runtime keys even if meta not present
                const extra = [
                    'preset', 'presetIntensity', 'themeColor', 'primaryColor', 'secondaryColor', 'tertiaryColor',
                    'primaryRainCount', 'secondaryRainCount', 'tertiaryRainCount',
                    'primaryRainSpeed', 'secondaryRainSpeed', 'tertiaryRainSpeed',
                    'primaryRainLength', 'secondaryRainLength', 'tertiaryRainLength',
                    'primaryRainSpacing', 'secondaryRainSpacing', 'tertiaryRainSpacing',
                    'primaryRainAngle', 'secondaryRainAngle', 'tertiaryRainAngle',
                    'primaryShape', 'secondaryShape', 'tertiaryShape',
                    'objectScale', 'maxDrops', 'useBlink', 'useGradient',
                    'breathingCycleSec', 'breathingMin', 'breathingMax',
                    'audioReactive', 'audioSource', 'audioFloor', 'audioCeiling', 'audioSensitivity', 'audioAttackMs', 'audioReleaseMs', 'audioMix'
                ];
                extra.forEach(k => {
                    if (this.keys.indexOf(k) === -1) this.keys.push(k);
                    if (typeof this.live[k] === 'undefined') {
                        const hostVal = (typeof window[k] !== 'undefined') ? window[k] : undefined;
                        this.live[k] = hostVal;
                        this.lastWindow[k] = hostVal;
                        this.userModified[k] = false;
                    }
                });
            }

            // set via script/preset (source = 'preset'|'script'|'user')
            set(name, value, source = 'script') {
                // Preset/script writes bypass lock (they *create* the lock)
                if (source !== 'preset' && this.lockedParams.has(name)) {
                    console.debug(`[Settings] ${name} is locked, ignores external writes and returns live[${name}] ${this.live[name]}`);
                    return this.live[name]; // ignore external writes if locked
                }
                this.live[name] = value;
                this.userModified[name] = (source === 'user');
                this.lastWindow[name] = value;
                try { window[name] = value; } catch (e) { /* ignore environments that lock window */ }

                console.debug(`[Settings] ${name} is not locked, returns desired value = ${value}`);
                return value;
            }

            // keep locked values in charge
            enforceLocks() {
                for (const k of this.lockedParams) {
                    try { window[k] = this.live[k]; } catch (e) { }
                }
            }

            // read cached value (fallback to window if completely missing)
            get(name, fallback) {
                if (typeof this.live[name] !== 'undefined') return this.live[name];
                if (typeof window[name] !== 'undefined') return window[name];
                return fallback;
            }

            // poll host/window to detect user/panel changes
            poll() {
                for (const k of this.keys) {
                    const winV = (typeof window[k] !== 'undefined') ? window[k] : undefined;
                    const lastV = this.lastWindow[k];

                    if (!this._equal(winV, lastV)) {
                        if (this.lockedParams.has(k)) {
                            const presetV = (this.presetValues && k in this.presetValues) ? this.presetValues[k] : undefined;
                            const overwrittenV = (this.overwrittenValue && k in this.overwrittenValue) ? this.overwrittenValue[k] : undefined;

                            if (presetV !== undefined && this._equal(winV, presetV)) {
                                // still at preset value
                                this.lastWindow[k] = winV;
                            } else if (overwrittenV !== undefined && this._equal(winV, overwrittenV)) {
                                // panel resync, restore preset
                                if (presetV !== undefined) {
                                    try { window[k] = presetV; } catch (e) { }
                                    this.lastWindow[k] = presetV;
                                }
                            } else if (presetV !== undefined) {
                                // user really touched slider → unlock
                                this.lockedParams.delete(k);
                                this.live[k] = winV;
                                this.lastWindow[k] = winV;
                                this.userModified[k] = true;
                                console.debug(`[Settings] User requested change for ${k}, Unlocking ${k}, value changed to ${winV}`);
                            } else {
                                // no preset value recorded → just unlock silently
                                this.lockedParams.delete(k);
                                console.debug(`[Settings] No preset value recorder, Unlocking ${k}`);
                            }
                        } else {
                            // not locked → normal update
                            this.live[k] = winV;
                            this.lastWindow[k] = winV;
                            this.userModified[k] = true;
                            console.debug(`[Settings] ${k} is not locked, value changed to ${winV} by regular update`);
                        }
                    }
                }
            }



            _equal(a, b) {
                if (typeof a === 'number' && typeof b === 'number' && isFinite(a) && isFinite(b)) return Math.abs(a - b) < 1e-9;
                return a === b;
            }

            // push cached values to window (safe sync)
            syncToWindow() {
                for (const k of this.keys) {
                    try { window[k] = this.live[k]; } catch (e) { /* ignore */ }
                }
            }

            // helper to mark a param as user-changed
            markUserChanged(name) { this.userModified[name] = true; }

            // Simple heuristic: if the window changed away from preset value, treat as slider move
            _isUserInteraction(name, winV, lastV) {
                console.debug(`[Settings] Unlocking ${name}, user changed from ${lastV} → ${winV}`);
                return true; // In SignalRGB, any change while locked should mean user touched it
            }
        }

        // create settings manager instance
        const Settings = new SettingsManager();

        // convenience wrapper matching earlier setParam signature
        function setParam(name, value) {
            return Settings.set(name, value, 'preset');
        }

        // ---------- Canvas setup ----------
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let canvasScaleFactor = 1;
        function applyCanvasScale() {
            const cssW = parseInt(canvas.getAttribute('width') || 320, 10);
            const cssH = parseInt(canvas.getAttribute('height') || 200, 10);
            const canvasScale = Number(Settings.get('objectScale', 100)) || 100;
            canvasScaleFactor = canvasScale / 100;
            canvas.width = Math.max(1, Math.round(cssW * canvasScaleFactor));
            canvas.height = Math.max(1, Math.round(cssH * canvasScaleFactor));
            canvas.style.width = cssW + 'px';
            canvas.style.height = cssH + 'px';
        }
        applyCanvasScale();
        let W = canvas.width, H = canvas.height;
        window.addEventListener('resize', () => { applyCanvasScale(); W = canvas.width; H = canvas.height; });

        // ---------- Runtime state ----------
        let lastTime = nowSec();
        let primaryDrops = [], secondaryDrops = [], tertiaryDrops = [];
        let audioEnv = 0;
        let lightningTimer = 0;
        let pulsarBursts = [];
        let pulsarLastSpawn = 0;
        let lastPreset = Settings.get('preset', undefined);

        // ---------- Helpers re: shapes/directions ----------
        function makeDir(angleDeg) {
            const rad = deg2rad(Number(angleDeg) || 0);
            const vx = Math.cos(rad);
            const vy = Math.sin(rad);
            const len = Math.hypot(vx, vy) || 1;
            return { vx: vx / len, vy: vy / len };
        }

        function spawnDrop(layer, params, colorRGB, angleDeg, scaleFactor, shape, blinkPeriod) {
            const dir = makeDir(angleDeg);
            const vx = dir.vx, vy = dir.vy;

            let px, py;
            if (Math.abs(vx) > Math.abs(vy)) {
                px = (vx > 0) ? -10 : W + 10;
                py = Math.random() * H;
            } else {
                px = Math.random() * W;
                py = (vy > 0) ? -10 : H + 10;
            }

            const baseSpeed = Number(params.speed) * scaleFactor;
            const speedVariation = 0.8 + Math.random() * 0.4;
            const speedPxPerSec = baseSpeed * Math.max(W, H);

            const drop = {
                x: px, y: py,
                vx: vx * speedPxPerSec * speedVariation,
                vy: vy * speedPxPerSec * speedVariation,
                len: params.len * Math.min(W, H) * scaleFactor,
                colorRGB,
                shape: shape,
                life: 1.0,
                phase: Math.random(),
                blinkPeriod: blinkPeriod || 0,
                // Stable shape + rotation state
                shapeSeed: Math.random(),        // stable random per drop
                spin: 0,                         // current rotation
                spinSpeed: (Math.random() * 2 - 1) * 0.8, // radians/sec, small range
                fixedAngle: Math.atan2(vy, vx),

            };

            layer.push(drop);
        }

        function updateLayer(layer, dt, scaleFactor, drift) {
            for (const d of layer) {
                if (drift) {
                    d.vx += drift.x * W * dt * scaleFactor + (drift.jitter * (Math.random() - 0.5)) * dt * 100;
                }
                d.x += d.vx * dt;
                d.y += d.vy * dt;
                // Smooth rotation update for shapes that rotate
                d.spin += d.spinSpeed * dt;

            }
            const objectScaleFactor = Number(Settings.get('objectScale', 100)) / 100;
            const cullMargin = 100 * objectScaleFactor;
            for (let i = layer.length - 1; i >= 0; i--) {
                const d = layer[i];
                if (d.x < -cullMargin || d.x > W + cullMargin || d.y < -cullMargin || d.y > H + cullMargin) {
                    layer.splice(i, 1);
                }
            }
        }

        function ensurePopulation(layer, desiredCount, params, colorRGB, angleDeg, maxDrops, scaleFactor, shape, blinkPeriod) {
            const cap = Math.min(Number(maxDrops) || 0, 99999);
            const target = clamp(Number(desiredCount) || 0, 0, cap);

            // Trim if too many
            if (layer.length > target) {
                layer.length = target;
                return;
            }

            // Spawn until target
            while (layer.length < target) {
                spawnDrop(layer, params, colorRGB, angleDeg, scaleFactor, shape, blinkPeriod);
            }
        }

        function blinkForDrop(d, t) {
            if (!d.blinkPeriod || d.blinkPeriod <= 0) return 1.0;
            const ph = (t / (d.blinkPeriod / 100) + d.phase) % 1;
            return (ph < 0.5) ? 1.0 : 0.35;
        }

        // ---------- Audio helpers (SignalRGB exposes getAudioLevel/getAudioRMS) ----------
        function verifyAudioAPI() {
            if (Settings.get('audioReactive')) {
                const hasAPI = (typeof getAudioLevel === 'function') || (typeof getAudioRMS === 'function');
                if (!hasAPI) {
                    console.warn('[PandaFlow] Audio-reactive disabled: getAudioLevel/getAudioRMS API not available.');
                    Settings.set('audioReactive', false, 'script');
                }
            }
        }

        function queryAudioLevel(source) {
            try {
                if (typeof getAudioLevel === 'function') return clamp(getAudioLevel(source), 0, 1);
                if (typeof getAudioRMS === 'function') return clamp(getAudioRMS(source), 0, 1);
            } catch (e) { }
            return 0;
        }

        function smoothEnvelope(prev, target, dt, attackMs, releaseMs) {
            const a = clamp(attackMs / 1000, 0.001, 2.0);
            const r = clamp(releaseMs / 1000, 0.001, 2.0);
            const coeff = (target > prev) ? Math.exp(-dt / a) : Math.exp(-dt / r);
            return target + (prev - target) * coeff;
        }

        // ---------- Pulsar bursts & static stars ----------
        function spawnPulsarBurst(kind) {
            const posX = W / 2, posY = H / 2;
            const colorRGB = hexToRgb(String(Settings.get('primaryColor') || '#FFFFFF'));
            const burst = { x: posX, y: posY, radius: 0.02, colorRGB, life: 1.0, maxLife: 1.0 };
            pulsarBursts.push(burst);
        }
        function updatePulsarBursts(dt) {
            for (let i = pulsarBursts.length - 1; i >= 0; i--) {
                const b = pulsarBursts[i];
                b.life -= dt;
                b.radius += dt * 0.4;
                if (b.life <= 0) pulsarBursts.splice(i, 1);
            }
        }
        function drawPulsarBursts() {
            for (const burst of pulsarBursts) {
                const [r, g, b] = burst.colorRGB;
                const alpha = (burst.life / burst.maxLife);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.lineWidth = Math.max(1, Math.round(0.03 * (W + H) / 2));
                ctx.beginPath();
                ctx.arc(W / 2, H / 2, burst.radius * Math.max(W, H), 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        let staticStars = [];
        let starsPrimAngle = 45;
        let starsSecAngle = 225;
        let starsPrimVel = 0.0;
        let starsSecVel = 0.0;
        function spawnStaticStars(count) {
            staticStars = [];
            for (let i = 0; i < count; i++) staticStars.push({ x: Math.random() * W, y: Math.random() * H, twinklePhase: Math.random(), life: Math.random() * Number(Settings.get('staticStarLifespan', 8) || 8) });
        }
        function updateStaticStars(dt) {
            for (let s of staticStars) {
                s.twinklePhase += dt * 0.5; if (s.twinklePhase > 1) s.twinklePhase -= 1;
                s.life += dt; if (s.life >= Number(Settings.get('staticStarLifespan', 8) || 8)) { s.x = Math.random() * W; s.y = Math.random() * H; s.twinklePhase = Math.random(); s.life = 0; }
            }
        }
        function drawStaticStars() {
            for (let s of staticStars) {
                const alpha = 0.5 + 0.5 * Math.sin(s.twinklePhase * Math.PI * 2);
                let starRGB;
                switch (String(Settings.get('staticStarColorSource', 'Custom'))) {
                    case 'Theme': starRGB = hexToRgb(String(Settings.get('themeColor') || '#000000')); break;
                    case 'Primary': starRGB = hexToRgb(String(Settings.get('primaryColor') || '#FFFFFF')); break;
                    case 'Secondary': starRGB = hexToRgb(String(Settings.get('secondaryColor') || '#FFFFFF')); break;
                    case 'Tertiary': starRGB = hexToRgb(String(Settings.get('tertiaryColor') || '#FFFFFF')); break;
                    case 'Random': starRGB = [Math.random() * 255, Math.random() * 255, Math.random() * 255]; break;
                    default: starRGB = hexToRgb(String(Settings.get('staticStarCustomColor') || '#FFFFFF')); break;
                }
                ctx.fillStyle = `rgba(${starRGB[0]},${starRGB[1]},${starRGB[2]},${alpha})`;
                ctx.beginPath(); ctx.arc(s.x, s.y, Number(Settings.get('staticStarSize', 2) || 2), 0, Math.PI * 2); ctx.fill();
            }
        }

        // ---------- Draw drops ----------
        function drawDrop(d, blink) {
            const alpha = clamp(d.life, 0, 1) * blink;
            const [r, g, b] = d.colorRGB;
            ctx.lineCap = 'round';

            const widthFactor = (Number(Settings.get('influenceWidth', 20)) / 100) * ((W + H) / 200);
            const ang = Math.atan2(d.vy, d.vx);
            const objectScaleFactor = Number(Settings.get('objectScale', 100)) / 100;
            const scaleLen = (d.len || 10) * widthFactor;

            switch (d.shape) {
                case 'Dot':
                    ctx.beginPath(); ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`; ctx.arc(d.x, d.y, scaleLen * 0.15, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'Star': {
                    const ang = Math.atan2(d.vy, d.vx);
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang);
                    ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.lineWidth = Math.max(1, scaleLen * 0.05);

                    ctx.beginPath(); ctx.moveTo(0, -scaleLen * 0.15); ctx.lineTo(scaleLen * 0.15, 0); ctx.lineTo(0, scaleLen * 0.15); ctx.lineTo(-scaleLen * 0.15, 0); ctx.closePath(); ctx.stroke();

                    const armLen = scaleLen * 0.25; const armWidth = scaleLen * 0.1;
                    ctx.beginPath(); ctx.moveTo(-armWidth, -scaleLen * 0.15); ctx.lineTo(armWidth, -scaleLen * 0.15); ctx.lineTo(0, -scaleLen * 0.15 - armLen); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(-armWidth, scaleLen * 0.15); ctx.lineTo(armWidth, scaleLen * 0.15); ctx.lineTo(0, scaleLen * 0.15 + armLen); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(-scaleLen * 0.15, -armWidth); ctx.lineTo(-scaleLen * 0.15, armWidth); ctx.lineTo(-scaleLen * 0.15 - armLen, 0); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(scaleLen * 0.15, -armWidth); ctx.lineTo(scaleLen * 0.15, armWidth); ctx.lineTo(scaleLen * 0.15 + armLen, 0); ctx.closePath(); ctx.fill();
                    ctx.restore();
                } break;
                case 'Sand':
                    ctx.beginPath(); ctx.fillStyle = `rgba(${r},${g},${b},${alpha * 0.7})`; ctx.arc(d.x, d.y, scaleLen * 0.1, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'WaterDroplet':
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang - Math.PI / 2); ctx.scale(scaleLen / 10, scaleLen / 10); ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(-3, -6, 0, -10); ctx.quadraticCurveTo(3, -6, 0, 0); ctx.fill(); ctx.restore();
                    break;
                case 'WaterDropletStorm':
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang - Math.PI / 2); ctx.scale(scaleLen / 10, scaleLen / 10); ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(-3, -5, 0, -25); ctx.quadraticCurveTo(3, -4, 0, 0); ctx.fill(); ctx.restore();
                    break;
                case 'Meteor': {
                    const ang = Math.atan2(d.vy, d.vx);
                    const scaleLenM = Number(Settings.get('meteorSize', 15)) * objectScaleFactor;

                    // --- Tail (independent from spin, aligned with velocity only) ---
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    ctx.rotate(ang); // only velocity angle, no spin
                    const grad = ctx.createLinearGradient(-scaleLenM * 3.75, 0, 0, 0);
                    grad.addColorStop(0, `rgba(${r},${g},${b},0)`);
                    grad.addColorStop(1, `rgba(${r},${g},${b},${alpha})`);
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = Math.max(1, scaleLenM * 0.33);
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-scaleLenM * 3.75, 0);
                    ctx.lineTo(-scaleLenM * 0.25, 0);
                    ctx.stroke();
                    ctx.restore();

                    // --- Body (irregular polygon with stable pseudo-randomness, rotates with spin) ---
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    ctx.rotate(ang + d.spin);
                    ctx.scale(scaleLenM / 10, scaleLenM / 10);
                    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;

                    // Stable pseudo-random shape from seeded RNG
                    const rng = seeded(d.shapeSeed);
                    const segments = 6 + Math.floor(rng() * 2);  // 6..7 sides
                    const baseRadius = scaleLenM * (0.26 + 0.02 * rng());
                    const spin = d.spin;

                    ctx.beginPath();
                    for (let i = 0; i < segments; i++) {
                        const a = spin + (i / segments) * Math.PI * 2;
                        const radius = baseRadius * (0.9 + 0.2 * rng()); // scalloped edges
                        const x = Math.cos(a) * radius;
                        const y = Math.sin(a) * radius;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } break;

                case 'Snow': {
                    const ang = Math.atan2(d.vy, d.vx);
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang);
                    const widthFactor = (Number(Settings.get('influenceWidth', 20)) / 100) * ((W + H) / 200);
                    const scaleLenS = (d.len || 10) * widthFactor * objectScaleFactor;
                    ctx.scale(scaleLenS / 10, scaleLenS / 10);
                    const twinkle = Math.sin((performance.now() / 1000 + d.phase) * 8) * 0.2; ctx.rotate(twinkle);
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(0, 5); ctx.moveTo(-3, -2); ctx.lineTo(3, 2); ctx.moveTo(-3, 2); ctx.lineTo(3, -2);
                    ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`; ctx.lineWidth = Math.max(1, scaleLenS * 0.12); ctx.lineCap = 'round'; ctx.stroke(); ctx.restore();
                } break;
                case 'StarShip': {
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang + Math.PI / 2);
                    const sl = Number(Settings.get('starShipSize', 14)) * objectScaleFactor; ctx.scale(sl / 10, sl / 10);
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(4, 4); ctx.arc(0, 4, 4, 0, Math.PI, true); ctx.lineTo(-4, 4); ctx.closePath(); ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`; ctx.fill(); ctx.restore();
                } break;
                case 'Panda': {
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    ctx.scale(scaleLen / 10, scaleLen / 10);
                    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;

                    ctx.beginPath();

                    // --- Head ---
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);

                    // --- Ears ---
                    ctx.arc(-3.5, -4, 2, 0, Math.PI * 2);
                    ctx.arc(3.5, -4, 2, 0, Math.PI * 2);

                    // --- Eye patches (holes) ---
                    ctx.moveTo(-2, -1);
                    ctx.arc(-2, -1, 1.2, 0, Math.PI * 2);
                    ctx.moveTo(2, -1);
                    ctx.arc(2, -1, 1.2, 0, Math.PI * 2);

                    // --- Nose (hole) ---
                    ctx.moveTo(0, 1);
                    ctx.arc(0, 1, 0.6, 0, Math.PI * 2);

                    // --- Mouth (hole) ---
                    // Wider smile for better visibility on low LED counts
                    ctx.moveTo(-1.5, 2.4);
                    ctx.arc(0, 2.4, 1.5, 0, Math.PI, false);

                    // Fill with even-odd rule so holes remain transparent
                    ctx.fill('evenodd');
                    ctx.restore();
                } break;
                default: {
                    const vx = d.vx, vy = d.vy;
                    const ang = Math.atan2(vy, vx);
                    const len = (d.len * objectScaleFactor) || (10 * objectScaleFactor);
                    const sx = -Math.cos(ang) * (len * 0.5); const sy = -Math.sin(ang) * (len * 0.5);
                    const ex = Math.cos(ang) * (len * 0.5); const ey = Math.sin(ang) * (len * 0.5);
                    ctx.beginPath(); const w = Math.max(1, Math.round((Number(Settings.get('influenceWidth', 20)) / 100) * ((W + H) / 200) * objectScaleFactor)); ctx.lineWidth = w; ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.moveTo(d.x + sx, d.y + sy); ctx.lineTo(d.x + ex, d.y + ey); ctx.stroke();
                } break;
            }
        }

        // ---------- Apply Preset + Lock ----------
        function applyPresetStatic() {
            Settings.lockedParams.clear(); // reset all locks

            const pi = Number(Settings.get('presetIntensity', 100)) || 100;
            const primAngleCurrent = Number(Settings.get('primaryRainAngle', 90)) || 90;
            const secAngleCurrent = Number(Settings.get('secondaryRainAngle', 60)) || 60;

            function lockSet(name, value) {

                // remember what was there before preset overwrote it
                Settings.overwrittenValue[name] = (typeof window[name] !== 'undefined') ? window[name] : null;
                Settings.presetValues[name] = value;   // remember preset value

                Settings.set(name, value, 'preset');
                Settings.lockedParams.add(name);
                console.debug("[LockSet]", name, "preset:", value, "overwritten:", Settings.overwrittenValue[name]);
            }

            switch (String(Settings.get('preset', 'Custom'))) {
                case 'Storm':
                    lockSet('primaryShape', 'WaterDropletStorm');
                    lockSet('secondaryShape', 'WaterDropletStorm');
                    lockSet('tertiaryShape', 'WaterDropletStorm');
                    lockSet('primaryRainCount', Math.round(40 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(35 * (pi / 100)));
                    lockSet('primaryRainSpeed', 500 * (pi / 100));
                    lockSet('secondaryRainSpeed', 480 * (pi / 100));
                    lockSet('primaryRainLength', 22);
                    lockSet('secondaryRainLength', 18);
                    lockSet('primaryRainSpacing', 12);
                    lockSet('secondaryRainSpacing', 12);
                    lockSet('tertiaryRainCount', 80);
                    lockSet('tertiaryRainSpeed', 500);
                    lockSet('tertiaryRainLength', 8);
                    lockSet('tertiaryRainSpacing', 15);
                    lockSet('tertiaryColor', '#FFD966');
                    lockSet('breathingCycleSec', 400);
                    lockSet('breathingMin', 8);
                    lockSet('breathingMax', 95);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Calm':
                    lockSet('primaryShape', 'Line');
                    lockSet('secondaryShape', 'Dot');
                    lockSet('tertiaryShape', 'Star');
                    lockSet('primaryRainCount', Math.round(8 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(6 * (pi / 100)));
                    lockSet('primaryRainSpeed', 120 * (pi / 100));
                    lockSet('secondaryRainSpeed', 100 * (pi / 100));
                    lockSet('primaryRainLength', 18);
                    lockSet('secondaryRainLength', 14);
                    lockSet('primaryRainSpacing', 22);
                    lockSet('secondaryRainSpacing', 24);
                    lockSet('tertiaryRainCount', 20);
                    lockSet('tertiaryRainSpeed', 120);
                    lockSet('tertiaryRainLength', 25);
                    lockSet('tertiaryRainSpacing', 20);
                    lockSet('tertiaryColor', '#B3E5FC');
                    lockSet('breathingCycleSec', 1000);
                    lockSet('breathingMin', 20);
                    lockSet('breathingMax', 50);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Waves':
                    lockSet('primaryShape', 'Dot');
                    lockSet('secondaryShape', 'Dot');
                    lockSet('tertiaryShape', 'Dot');
                    lockSet('primaryRainCount', Math.round(16 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(16 * (pi / 100)));
                    lockSet('primaryRainSpeed', 200 * (pi / 100));
                    lockSet('secondaryRainSpeed', 200 * (pi / 100));
                    lockSet('primaryRainLength', 20);
                    lockSet('secondaryRainLength', 20);
                    lockSet('primaryRainSpacing', 16);
                    lockSet('secondaryRainSpacing', 16);
                    lockSet('tertiaryRainCount', 40);
                    lockSet('tertiaryRainSpeed', 180);
                    lockSet('tertiaryRainLength', 15);
                    lockSet('tertiaryRainSpacing', 18);
                    lockSet('tertiaryColor', '#4DD0E1');
                    lockSet('breathingCycleSec', 800);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Rain':
                    lockSet('primaryShape', 'WaterDroplet');
                    lockSet('secondaryShape', 'WaterDroplet');
                    lockSet('tertiaryShape', 'WaterDroplet');
                    lockSet('primaryRainCount', Math.round(20 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(20 * (pi / 100)));
                    lockSet('primaryRainSpeed', 250 * (pi / 100));
                    lockSet('secondaryRainSpeed', 230 * (pi / 100));
                    lockSet('primaryRainLength', 16);
                    lockSet('secondaryRainLength', 14);
                    lockSet('primaryRainSpacing', 18);
                    lockSet('secondaryRainSpacing', 18);
                    lockSet('tertiaryRainCount', 60);
                    lockSet('tertiaryRainSpeed', 200);
                    lockSet('tertiaryRainLength', 12);
                    lockSet('tertiaryRainSpacing', 16);
                    lockSet('tertiaryColor', '#90CAF9');
                    lockSet('breathingCycleSec', 700);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Snow':
                    lockSet('primaryShape', 'Snow');
                    lockSet('secondaryShape', 'Snow');
                    lockSet('tertiaryShape', 'Snow');
                    lockSet('primaryRainCount', Math.round(24 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(24 * (pi / 100)));
                    lockSet('primaryRainSpeed', 80 * (pi / 100));
                    lockSet('secondaryRainSpeed', 70 * (pi / 100));
                    lockSet('primaryRainLength', 6);
                    lockSet('secondaryRainLength', 6);
                    lockSet('primaryRainSpacing', 10);
                    lockSet('secondaryRainSpacing', 10);
                    lockSet('tertiaryRainCount', 30);
                    lockSet('tertiaryRainSpeed', 80);
                    lockSet('tertiaryRainLength', 20);
                    lockSet('tertiaryRainSpacing', 25);
                    lockSet('tertiaryColor', '#FFF8E1');
                    lockSet('breathingCycleSec', 1200);
                    lockSet('breathingMin', 25);
                    lockSet('breathingMax', 55);
                    lockSet('useBlink', true);
                    lockSet('useGradient', false);
                    break;

                case 'Sandstorm':
                    lockSet('primaryShape', 'Sand');
                    lockSet('secondaryShape', 'Sand');
                    lockSet('tertiaryShape', 'Sand');
                    lockSet('primaryRainCount', Math.round(50 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(45 * (pi / 100)));
                    lockSet('primaryRainSpeed', 400 * (pi / 100));
                    lockSet('secondaryRainSpeed', 380 * (pi / 100));
                    lockSet('primaryRainLength', 15);
                    lockSet('secondaryRainLength', 12);
                    lockSet('primaryRainSpacing', 10);
                    lockSet('secondaryRainSpacing', 10);
                    lockSet('tertiaryRainCount', 70);
                    lockSet('tertiaryRainSpeed', 400);
                    lockSet('tertiaryRainLength', 10);
                    lockSet('tertiaryRainSpacing', 14);
                    lockSet('tertiaryColor', '#D7B899');
                    lockSet('breathingCycleSec', 500);
                    lockSet('breathingMin', 15);
                    lockSet('breathingMax', 65);
                    lockSet('useBlink', true);
                    lockSet('useGradient', true);
                    break;

                case 'Pulsar':
                case 'Pulsar2':
                    lockSet('primaryShape', 'Star');
                    lockSet('secondaryShape', 'Meteor');
                    lockSet('tertiaryShape', 'StarShip');
                    lockSet('primaryRainCount', 40);
                    lockSet('primaryRainSpeed', 500);
                    lockSet('primaryRainLength', 15);
                    lockSet('primaryRainSpacing', 20);
                    lockSet('primaryRainAngle', 90);
                    lockSet('primaryColor', '#FFFFFF');
                    lockSet('secondaryRainCount', 20);
                    lockSet('secondaryRainSpeed', 300);
                    lockSet('secondaryRainLength', 20);
                    lockSet('secondaryRainSpacing', 25);
                    lockSet('secondaryRainAngle', 90);
                    lockSet('secondaryColor', '#80D8FF');
                    lockSet('tertiaryRainCount', 5);
                    lockSet('tertiaryRainSpeed', 700);
                    lockSet('tertiaryRainLength', 12);
                    lockSet('tertiaryRainSpacing', 18);
                    lockSet('tertiaryColor', '#FFEB3B');
                    lockSet('breathingCycleSec', 250);
                    lockSet('breathingMin', 5);
                    lockSet('breathingMax', 100);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Stars':
                    lockSet('primaryShape', 'Star');
                    lockSet('secondaryShape', 'Meteor');
                    lockSet('tertiaryShape', 'StarShip');
                    lockSet('primaryRainCount', Math.round(6 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(4 * (pi / 100)));
                    lockSet('primaryRainSpeed', 500 * (pi / 100));
                    lockSet('secondaryRainSpeed', 480 * (pi / 100));
                    lockSet('primaryRainLength', 12);
                    lockSet('secondaryRainLength', 10);
                    lockSet('primaryRainSpacing', 30);
                    lockSet('secondaryRainSpacing', 30);
                    lockSet('tertiaryRainCount', 15);
                    lockSet('tertiaryRainSpeed', 300);
                    lockSet('tertiaryRainLength', 8);
                    lockSet('tertiaryRainSpacing', 20);
                    lockSet('tertiaryColor', '#FFF59D');
                    lockSet('breathingCycleSec', 1500);
                    lockSet('breathingMin', 5);
                    lockSet('breathingMax', 20);
                    lockSet('useBlink', true);
                    lockSet('useGradient', true);
                    break;

                default:
                    // Custom or unknown - keep existing cached values
                    break;
            }

            // ensure window has up-to-date values
            Settings.syncToWindow();
        }

        // Behaviour
        function computeBehavior(now, dt, Settings) {
            const base = {
                primAngle: Number(Settings.get('primaryRainAngle', 90)),
                secAngle: Number(Settings.get('secondaryRainAngle', 60)),
                tertAngle: Number(Settings.get('tertiaryRainAngle', 120)),
                lightningOverlay: 0, drift: null, blurAmount: 0
            };

            const preset = String(Settings.get('preset', 'Custom'));
            const intensity = Number(Settings.get('presetIntensity', 100)) / 100;

            if (preset === 'Storm') {
                const gustAmp = scaleWithIntensity(3, intensity, 'range', 1, 2);
                const gust = (Math.sin(now * 1.7) + Math.sin(now * 2.3 + 1.1)) * gustAmp;
                base.primAngle += gust;
                base.secAngle -= gust * 0.7;

                if (lightningTimer <= 0 && Math.random() < (Number(Settings.get('stormLightningChance', 100)) / 10000) * intensity) {
                    lightningTimer = 0.20 + Math.random() * scaleWithIntensity(0.15, intensity);
                    if (Math.random() < 0.2) setTimeout(() => { lightningTimer = scaleWithIntensity(0.15, intensity); }, 150);
                }
                if (lightningTimer > 0) base.lightningOverlay = clamp(lightningTimer / 0.35, 0, 1);

                if (Math.random() < (Number(Settings.get('stormMicroGustChance', 20)) / 10000) * intensity) {
                    base.primAngle += (Math.random() < 0.5 ? -10 : 10) * intensity;
                    base.secAngle += (Math.random() < 0.5 ? -7 : 7) * intensity;
                }
                base.blurAmount = scaleBlur(0.35 * intensity, canvas);

            } else if (preset === 'Calm') {
                const sway = Math.sin(now * 0.3) * scaleWithIntensity(5, intensity);
                base.primAngle = 90 + sway;
                base.secAngle = 90 - sway;
                base.blurAmount = scaleBlur(0.15 * intensity, canvas);

            } else if (preset === 'Waves') {
                const swayAmp = scaleWithIntensity(20, intensity);
                const sway = Math.sin(now * 0.8) * swayAmp;
                base.primAngle = 60 + sway;
                base.secAngle = 120 - sway;
                base.blurAmount = scaleBlur(0.35 * intensity, canvas);

            } else if (preset === 'Rain') {
                const sway = Math.sin(now * 1.2) * scaleWithIntensity(5, intensity);
                base.primAngle = 90 + sway;
                base.secAngle = 90 - sway;
                base.blurAmount = scaleBlur(0.65 * intensity, canvas);

            } else if (preset === 'Snow') {
                const driftX = 0.05 * (Math.sin(now * 0.7) + 0.5 * Math.sin(now * 1.1 + 2.1)) * intensity;
                base.drift = { x: driftX, jitter: scaleWithIntensity(0.25, intensity, 'range', 1, 2) };
                const sway = Math.sin(now * 0.6) * scaleWithIntensity(10, intensity);
                base.primAngle = 90 + sway;
                base.secAngle = 90 - sway;
                base.blurAmount = scaleBlur(0.35 * intensity, canvas);

            } else if (preset === 'Sandstorm') {
                const gustAmp = scaleWithIntensity(8, intensity, 'range', 1, 2);
                const gust = Math.sin(now * 1.3) * gustAmp;
                base.primAngle = 15 + gust;
                base.secAngle = 165 - gust;

                const phase = now * 5.0;
                const haze = 0.6 * Math.sin(phase) + 0.4 * Math.sin(phase * 0.53 + 1.7) + 0.3 * Math.sin(phase * 0.37 + 0.3);
                base.lightningOverlay = clamp(0.08 + 0.07 * haze * intensity, 0, 0.3);

                if (Math.random() < (Number(Settings.get('sandstormGustBurstChance', 30)) / 10000) * intensity) {
                    const burst = scaleWithIntensity(15, intensity);
                    base.primAngle += (Math.random() < 0.5 ? -burst : burst);
                    base.secAngle += (Math.random() < 0.5 ? -burst : burst);
                    base.tertAngle += (Math.random() < 0.5 ? -burst : burst);
                }
                base.blurAmount = scaleBlur(0.35 * intensity, canvas);

            } else if (preset === 'Pulsar') {
                const phase = (now % (Number(Settings.get('breathingCycleSec', 750)) / 100)) / (Number(Settings.get('breathingCycleSec', 750)) / 100);
                if (phase < 0.05 && now - pulsarLastSpawn > (Number(Settings.get('breathingCycleSec', 750)) / 100) * 0.5) {
                    pulsarLastSpawn = now;
                    for (let i = 0; i < Math.ceil(intensity * 2); i++) {
                        setTimeout(() => spawnPulsarBurst('Pulsar'), i * 150);
                    }
                }

            } else if (preset === 'Pulsar2') {
                const phase = (now % (Number(Settings.get('breathingCycleSec', 750)) / 100)) / (Number(Settings.get('breathingCycleSec', 750)) / 100);
                if (phase < 0.05 && now - pulsarLastSpawn > (Number(Settings.get('breathingCycleSec', 750)) / 100) * 0.5) {
                    pulsarLastSpawn = now;
                    const rings = 2 + Math.floor(Math.random() * 2 * intensity);
                    for (let i = 0; i < rings; i++) {
                        setTimeout(() => spawnPulsarBurst('Pulsar2'), i * 200);
                    }
                }
            } else if (preset === 'Stars') {
                // Smooth angle drift using low-frequency noise
                const n1 = Math.sin(now * 0.2) + 0.5 * Math.sin(now * 0.37);
                const n2 = Math.sin(now * 0.17 + 1.1) + 0.5 * Math.sin(now * 0.29 + 0.7);
                const intensity = Number(Settings.get('presetIntensity', 100)) / 100;

                // Velocity scaled with intensity (degrees/sec)
                starsPrimVel = 5 * intensity * n1;
                starsSecVel = 5 * intensity * n2;

                starsPrimAngle += starsPrimVel * dt;
                starsSecAngle += starsSecVel * dt;

                base.primAngle = starsPrimAngle;
                base.secAngle = starsSecAngle;

                if (Math.random() < (Number(Settings.get('starsMeteorShowerChance', 15)) / 10000) * intensity) {
                    base.meteorShower = true;
                }
            }
            return base;
        }


        // ---------- Main loop (clean) ----------
        const PARTICLE_DELAY = 3375; // ms
        let startTime = performance.now();
        function update() {
            const elapsed = performance.now() - startTime;
            try {
                const now = nowSec();
                let dt = clamp(now - lastTime, 0, 0.05);
                lastTime = now;

                // poll host for changes (panel/user) - this updates cache only when something changed
                Settings.poll();
                // re-apply locked values so presets stay in charge
                Settings.enforceLocks();

                // check preset changes
                const presetNow = String(Settings.get('preset', 'Custom'));
                const presetChanged = (lastPreset !== presetNow);
                if (presetChanged) {
                    // presets set values once and sync them to window so panel sees the new values
                    applyPresetStatic();

                    // handle pulsar immediate spawn
                    if (presetNow === 'Pulsar' || presetNow === 'Pulsar2') { spawnPulsarBurst(presetNow); pulsarLastSpawn = now; }

                    if (presetNow === 'Stars') spawnStaticStars(Number(Settings.get('staticStarCount', 50) || 50));

                    lastPreset = presetNow;
                }

                // verify audio availability only when preset changes or when audioReactive turned on
                verifyAudioAPI();

                // read values from Settings for the rest of the loop
                const objectScaleFactor = Number(Settings.get('objectScale', 100)) / 100;
                const maxDrops = Number(Settings.get('maxDrops', 500)) || 500;

                // breathing factor
                const baseRGB = (() => {
                    const src = String(Settings.get('breathingColorSource', 'Theme'));
                    switch (src) {
                        case 'Primary': return hexToRgb(String(Settings.get('primaryColor') || '#000000'));
                        case 'Secondary': return hexToRgb(String(Settings.get('secondaryColor') || '#000000'));
                        case 'Tertiary': return hexToRgb(String(Settings.get('tertiaryColor') || '#000000'));
                        case 'Random': return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
                        case 'Custom': return hexToRgb(String(Settings.get('breathingCustomColor') || '#FFFFFF'));
                        default: return hexToRgb(String(Settings.get('themeColor') || '#000000'));
                    }
                })();

                const fBreath = (function () { const cyc = Number(Settings.get('breathingCycleSec', 750)) || 750; const minV = Number(Settings.get('breathingMin', 15)) / 100 || 0.15; const maxV = Number(Settings.get('breathingMax', 80)) / 100 || 0.8; const phase = (now % (cyc / 100)) / (cyc / 100); const s = 0.5 - 0.5 * Math.cos(phase * Math.PI * 2); const p = Math.pow(s, 1 / 2.2); return mix(minV, maxV, p); })();

                let f = fBreath;
                if (Settings.get('audioReactive')) {
                    let lvl = queryAudioLevel(String(Settings.get('audioSource', 'Microphone')));
                    lvl = clamp(lvl * (Number(Settings.get('audioSensitivity', 100)) / 100), 0, 1);
                    const win = (Number(Settings.get('audioCeiling', 35)) / 100) - (Number(Settings.get('audioFloor', 5)) / 100);
                    const norm = win <= 0 ? 0 : clamp((lvl - (Number(Settings.get('audioFloor', 5)) / 100)) / win, 0, 1);
                    audioEnv = smoothEnvelope(audioEnv, norm, dt, Number(Settings.get('audioAttackMs', 30)), Number(Settings.get('audioReleaseMs', 180)));
                    const fAudio = mix(Number(Settings.get('breathingMin', 15)) / 100, Number(Settings.get('breathingMax', 80)) / 100, audioEnv);
                    f = mix(fBreath, fAudio, Number(Settings.get('audioMix', 55)) / 100);
                }

                if (lightningTimer > 0) lightningTimer = Math.max(0, lightningTimer - dt);

                // behavior & per-preset dynamics (angles, gusts, lightning overlay)
                const behavior = computeBehavior(now, dt, Settings);

                const overlay = behavior.lightningOverlay || 0;
                const overlayRGB = [255, 240, 200];

                let bgR = baseRGB[0] * f; let bgG = baseRGB[1] * f; let bgB = baseRGB[2] * f;
                if (overlay > 0) { bgR = (1 - overlay) * bgR + overlay * overlayRGB[0]; bgG = (1 - overlay) * bgG + overlay * overlayRGB[1]; bgB = (1 - overlay) * bgB + overlay * overlayRGB[2]; }

                // prepare colors and params for population
                const primaryRGB = hexToRgb(String(Settings.get('primaryColor') || '#00B3B3'));
                const secondaryRGB = hexToRgb(String(Settings.get('secondaryColor') || '#E6F6FF'));
                const tertiaryRGB = hexToRgb(String(Settings.get('tertiaryColor') || '#FFD966'));

                const primParams = { speed: (Number(Settings.get('primaryRainSpeed', 220)) / 1000), len: Number(Settings.get('primaryRainLength', 20)) / 100, spacing: Number(Settings.get('primaryRainSpacing', 18)) / 100 };
                const secParams = { speed: (Number(Settings.get('secondaryRainSpeed', 240)) / 1000), len: Number(Settings.get('secondaryRainLength', 12)) / 100, spacing: Number(Settings.get('secondaryRainSpacing', 14)) / 100 };
                const tertParams = { speed: (Number(Settings.get('tertiaryRainSpeed', 200)) / 1000), len: Number(Settings.get('tertiaryRainLength', 15)) / 100, spacing: Number(Settings.get('tertiaryRainSpacing', 18)) / 100 };

                // cap arrays
                if (primaryDrops.length > (Number(Settings.get('maxDrops', 500)) || 500)) primaryDrops.length = Number(Settings.get('maxDrops', 500)) || 500;
                if (secondaryDrops.length > (Number(Settings.get('maxDrops', 500)) || 500)) secondaryDrops.length = Number(Settings.get('maxDrops', 500)) || 500;
                if (tertiaryDrops.length > (Number(Settings.get('maxDrops', 500)) || 500)) tertiaryDrops.length = Number(Settings.get('maxDrops', 500)) || 500;
                // meteor shower logic
                if (behavior.meteorShower) {
                    const baseAngle = Math.random() * Math.PI * 2; const angleSpread = (5 * Math.PI) / 180; const speedBoost = Number(Settings.get('meteorShowerBoost', 3) || 3);
                    const primParamsBoost = { ...primParams, speed: primParams.speed * speedBoost };
                    const secParamsBoost = { ...secParams, speed: secParams.speed * speedBoost };
                    const tertParamsBoost = { ...tertParams, speed: tertParams.speed * speedBoost };
                    for (let i = 0; i < Number(Settings.get('primaryMeteorCount', 3) || 3); i++) { const offset = (Math.random() * 2 - 1) * angleSpread; const angle = rad2deg(baseAngle + offset); spawnDrop(primaryDrops, primParamsBoost, primaryRGB, angle, objectScaleFactor, 'Meteor', 0); }
                    for (let i = 0; i < Number(Settings.get('secondaryMeteorCount', 3) || 3); i++) { const offset = (Math.random() * 2 - 1) * angleSpread; const angle = rad2deg(baseAngle + offset); spawnDrop(secondaryDrops, secParamsBoost, secondaryRGB, angle, objectScaleFactor, 'Meteor', 0); }
                    for (let i = 0; i < Number(Settings.get('tertiaryMeteorCount', 3) || 3); i++) { const offset = (Math.random() * 2 - 1) * angleSpread; const angle = rad2deg(baseAngle + offset); spawnDrop(tertiaryDrops, tertParamsBoost, tertiaryRGB, angle, objectScaleFactor, 'Meteor', 0); }
                }

                updateLayer(primaryDrops, dt, Number(Settings.get('objectScale', 100)) / 100, behavior.drift);
                updateLayer(secondaryDrops, dt, Number(Settings.get('objectScale', 100)) / 100, behavior.drift);
                updateLayer(tertiaryDrops, dt, Number(Settings.get('objectScale', 100)) / 100, behavior.drift);

                // Clear & background
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.filter = 'none';
                ctx.clearRect(0, 0, W, H);

                if (elapsed <= PARTICLE_DELAY) {
                    maybePreloadBackground(
                        drawSplashLogos,
                        'https://raw.githubusercontent.com/iomatix/SignalRGB-Effects/main/PandaFlow/pandaflow-logo.png'
                    );
                    return; // Wait until splash screen disappears
                }

                if (Number(Settings.get('usePicture', 0) === 1)) {
                    maybePreloadBackground(drawBackgroundImage);
                } else {
                    ctx.fillStyle = `rgb(${Math.round(bgR)}, ${Math.round(bgG)}, ${Math.round(bgB)})`;
                    ctx.fillRect(0, 0, W, H);
                }



                if (String(Settings.get('preset', 'Custom')) === 'Pulsar' || String(Settings.get('preset', 'Custom')) === 'Pulsar2') {
                    updatePulsarBursts(dt); drawPulsarBursts(); updateAndDrawLayers(dt, behavior);
                } else {
                    if (behavior.blurAmount > 0) {
                        ctx.save();
                        ctx.filter = `blur(${behavior.blurAmount}px)`;
                    }
                    if (String(Settings.get('preset', 'Custom')) === 'Stars') { updateStaticStars(dt); drawStaticStars(); }
                    updateAndDrawLayers(dt, behavior);
                    if (behavior.blurAmount > 0) {
                        ctx.restore(); // restores filter and any accidental state
                    } else {
                        ctx.filter = 'none';
                    }
                }
            } catch (e) { console.error('Update loop error:', e); }
            finally { window.requestAnimationFrame(update); }
        }


        function updateAndDrawLayers(dt, behavior) {
            const now = nowSec();

            // Compute intensity once
            const intensity = Number(Settings.get('presetIntensity', 100)) / 100;

            // Read base counts from settings (locked by preset when applicable)
            const basePrimCount = Number(Settings.get('primaryRainCount', 10) || 10);
            const baseSecCount = Number(Settings.get('secondaryRainCount', 10) || 10);
            const baseTertCount = Number(Settings.get('tertiaryRainCount', 10) || 10);

            // Scale counts dynamically with intensity; clamp by maxDrops later
            const desiredPrim = scaleCount(basePrimCount, intensity);
            const desiredSec = scaleCount(baseSecCount, intensity);
            const desiredTert = scaleCount(baseTertCount, intensity);

            const objectScaleFactor = Number(Settings.get('objectScale', 100)) / 100;
            const primParams = { speed: (Number(Settings.get('primaryRainSpeed', 220)) / 1000), len: Number(Settings.get('primaryRainLength', 20)) / 100, spacing: Number(Settings.get('primaryRainSpacing', 18)) / 100 };
            const secParams = { speed: (Number(Settings.get('secondaryRainSpeed', 240)) / 1000), len: Number(Settings.get('secondaryRainLength', 12)) / 100, spacing: Number(Settings.get('secondaryRainSpacing', 14)) / 100 };
            const tertParams = { speed: (Number(Settings.get('tertiaryRainSpeed', 200)) / 1000), len: Number(Settings.get('tertiaryRainLength', 15)) / 100, spacing: Number(Settings.get('tertiaryRainSpacing', 18)) / 100 };

            const primaryRGB = hexToRgb(String(Settings.get('primaryColor') || '#00B3B3'));
            const secondaryRGB = hexToRgb(String(Settings.get('secondaryColor') || '#E6F6FF'));
            const tertiaryRGB = hexToRgb(String(Settings.get('tertiaryColor') || '#FFD966'));

            // Ensure populations (this already uses maxDrops param so normally will not exceed it)
            ensurePopulation(primaryDrops, desiredPrim, primParams, primaryRGB, Number(behavior.primAngle || Number(Settings.get('primaryRainAngle', 90))), Number(Settings.get('maxDrops', 500)), objectScaleFactor, Settings.get('primaryShape', 'Line'), Number(Settings.get('primaryRainBlinkPeriod', 28)));
            ensurePopulation(secondaryDrops, desiredSec, secParams, secondaryRGB, Number(behavior.secAngle || Number(Settings.get('secondaryRainAngle', 60))), Number(Settings.get('maxDrops', 500)), objectScaleFactor, Settings.get('secondaryShape', 'Dot'), Number(Settings.get('secondaryRainBlinkPeriod', 28)));
            ensurePopulation(tertiaryDrops, desiredTert, tertParams, tertiaryRGB, Number(behavior.tertAngle || Number(Settings.get('tertiaryRainAngle', 120))), Number(Settings.get('maxDrops', 500)), objectScaleFactor, Settings.get('tertiaryShape', 'Star'), Number(Settings.get('tertiaryRainBlinkPeriod', 28)));

            // --- IMPORTANT: cap arrays to maxDrops (missing in the broken version) ---
            const maxDrops = Number(Settings.get('maxDrops', 500)) || 500;
            if (primaryDrops.length > maxDrops) primaryDrops.length = maxDrops;
            if (secondaryDrops.length > maxDrops) secondaryDrops.length = maxDrops;
            if (tertiaryDrops.length > maxDrops) tertiaryDrops.length = maxDrops;

            // Meteor shower logic (fixed spread / boost creation using spread operator)
            if (behavior.meteorShower) {
                const baseAngle = Math.random() * Math.PI * 2;
                const angleSpread = (5 * Math.PI) / 180;
                const speedBoost = Number(Settings.get('meteorShowerBoost', 3) || 3);

                // --- FIX: use spread syntax '...primParams' not invalid '.primParams' ---
                const primParamsBoost = { ...primParams, speed: primParams.speed * speedBoost };
                const secParamsBoost = { ...secParams, speed: secParams.speed * speedBoost };
                const tertParamsBoost = { ...tertParams, speed: tertParams.speed * speedBoost };

                for (let i = 0; i < Number(Settings.get('primaryMeteorCount', 3) || 3); i++) {
                    const offset = (Math.random() * 2 - 1) * angleSpread;
                    const angle = rad2deg(baseAngle + offset);
                    spawnDrop(primaryDrops, primParamsBoost, primaryRGB, angle, objectScaleFactor, 'Meteor', 0);
                }
                for (let i = 0; i < Number(Settings.get('secondaryMeteorCount', 3) || 3); i++) {
                    const offset = (Math.random() * 2 - 1) * angleSpread;
                    const angle = rad2deg(baseAngle + offset);
                    spawnDrop(secondaryDrops, secParamsBoost, secondaryRGB, angle, objectScaleFactor, 'Meteor', 0);
                }
                for (let i = 0; i < Number(Settings.get('tertiaryMeteorCount', 3) || 3); i++) {
                    const offset = (Math.random() * 2 - 1) * angleSpread;
                    const angle = rad2deg(baseAngle + offset);
                    spawnDrop(tertiaryDrops, tertParamsBoost, tertiaryRGB, angle, objectScaleFactor, 'Meteor', 0);
                }
            }

            // Update positions (with drift) and draw
            updateLayer(primaryDrops, dt, objectScaleFactor, behavior.drift);
            updateLayer(secondaryDrops, dt, objectScaleFactor, behavior.drift);
            updateLayer(tertiaryDrops, dt, objectScaleFactor, behavior.drift);

            for (const d of primaryDrops) drawDrop(d, Settings.get('useBlink') ? blinkForDrop(d, now) : 1.0);
            for (const d of secondaryDrops) drawDrop(d, Settings.get('useBlink') ? blinkForDrop(d, now) : 1.0);
            for (const d of tertiaryDrops) drawDrop(d, Settings.get('useBlink') ? blinkForDrop(d, now) : 1.0);
        }
        // start
        window.requestAnimationFrame(update);

    </script>
</body>

</html>