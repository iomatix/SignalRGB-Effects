<!DOCTYPE html>
<html>

<head>
    <title>PandaFlow Weather (Refactor)</title>
    <meta
        description="Breathing + Alternating Rain + Audio-Reactive + Canvas Scale + Presets + Drop Shapes - Refactored for SignalRGB" />
    <meta publisher="iomatix" />

    <!-- Presets (unchanged interface for SignalRGB) -->
    <meta property="preset" label="Weather Preset" type="list" default="Custom"
        values="Custom,Storm,Calm,Waves,Rain,Snow,Sandstorm,Pulsar,Pulsar2,Stars" />
    <meta property="presetIntensity" label="Preset Intensity (10=0.1, 100=1.0, 300=3.0)" type="number" min="10"
        max="999" step="5" default="100" />

    <meta property="stormLightningChance" label="Storm Lightning Chance (100=0.01 per frame)" type="number" min="0"
        max="1500" step="1" default="100" />
    <meta property="stormMicroGustChance" label="Storm Micro-Gust Chance (20=0.002 per frame)" type="number" min="0"
        max="550" step="1" default="20" />
    <meta property="sandstormGustBurstChance" label="Sandstorm Gust Burst Chance (30=0.003 per frame)" type="number"
        min="0" max="550" step="1" default="30" />
    <meta property="starShipSize" label="StarShip Size" type="number" min="1" max="99" step="1" default="14" />
    <meta property="meteorSize" label="Meteor Size" type="number" min="1" max="99" step="1" default="15" />
    <meta property="starsMeteorShowerChance" label="Stars Meteor Shower Chance (15=0.0015 per frame)" type="number"
        min="0" max="250" step="1" default="15" />
    <meta property="primaryMeteorCount" label="Primary Meteors Per Shower" type="number" min="0" max="50" step="1"
        default="3" />
    <meta property="secondaryMeteorCount" label="Secondary Meteors Per Shower" type="number" min="0" max="50" step="1"
        default="3" />
    <meta property="tertiaryMeteorCount" label="Tertiary Meteors Per Shower" type="number" min="0" max="50" step="1"
        default="3" />
    <meta property="meteorShowerBoost" label="Stars Meteor Speed Boost" type="number" min="1" max="10" step="1"
        default="3" />
    <meta property="staticStarLifespan" label="Static Star Lifespan (sec)" type="number" min="1" max="320" step="1"
        default="8" />
    <meta property="staticStarCount" label="Static Stars Count" type="number" min="1" max="999" step="1" default="50" />
    <meta property="staticStarSize" label="Static Star Size" type="number" min="1" max="99" step="1" default="2" />
    <meta property="staticStarColorSource" label="Static Stars Color Source" type="list" default="Custom"
        values="Theme,Primary,Secondary,Tertiary,Random,Custom" />
    <meta property="staticStarCustomColor" label="Custom Static Star Color" type="color" default="#FFFFFF" />
    <!-- Colors -->
    <meta property="themeColor" label="Theme / Background Color" type="color" default="#101014" />
    <!-- Breathing -->
    <meta property="breathingColorSource" label="Breathing Color Source" type="list" default="Theme"
        values="Theme,Primary,Secondary,Tertiary,Random,Custom" />
    <meta property="breathingCustomColor" label="Custom Breathing Color" type="color" default="#FFFFFF" />
    <meta property="breathingCycleSec" label="Breathing Cycle Seconds (750=7.5s)" type="number" min="25" max="1500"
        step="5" default="750" />
    <meta property="breathingMin" label="Breathing Minimum Intensity (15=0.15)" type="number" min="0" max="100" step="1"
        default="15" />
    <meta property="breathingMax" label="Breathing Maximum Intensity (80=0.80)" type="number" min="0" max="100" step="1"
        default="80" />

    <!-- Audio-reactive -->
    <meta property="audioReactive" label="Audio Reactive (may cause issues if API not available)" type="boolean"
        default="false" />
    <meta property="audioSource" label="Audio Source" type="list" default="Microphone" values="Microphone,System" />
    <meta property="audioFloor" label="Audio Floor (5=0.05)" type="number" min="0" max="50" step="1" default="5" />
    <meta property="audioCeiling" label="Audio Ceiling (35=0.35)" type="number" min="5" max="100" step="1"
        default="35" />
    <meta property="audioSensitivity" label="Audio Sensitivity (100=1.0)" type="number" min="20" max="400" step="10"
        default="100" />
    <meta property="audioAttackMs" label="Audio Attack Milliseconds" type="number" min="1" max="200" step="1"
        default="30" />
    <meta property="audioReleaseMs" label="Audio Release Milliseconds" type="number" min="10" max="1000" step="10"
        default="180" />
    <meta property="audioMix" label="Audio Mix Blend (55=0.55)" type="number" min="0" max="100" step="1" default="55" />

    <!-- Canvas -->
    <meta property="objectScale" label="Objects scale on canvas (100=1.0)" type="number" min="25" max="250" step="5"
        default="100" />

    <!-- Drop -->
    <meta property="primaryShape" label="Primary Drop Shape" type="list" default="Line"
        values="Line,Dot,WaterDroplet,WaterDropletStorm,Sand,Snow,Meteor,Star,StarShip" />

    <meta property="secondaryShape" label="Secondary Drop Shape" type="list" default="Dot"
        values="Line,Dot,WaterDroplet,WaterDropletStorm,Sand,Snow,Meteor,Star,StarShip" />

    <meta property="tertiaryShape" label="Tertiary Drop Shape" type="list" default="Star"
        values="Line,Dot,WaterDroplet,WaterDropletStorm,Sand,Snow,Meteor,Star,StarShip" />

    <!-- Primary rain -->
    <meta property="primaryRainCount" label="Primary Drop Count" type="number" min="0" max="60" step="1" default="10" />
    <meta property="primaryRainSpeed" label="Primary Drop Speed" type="number" min="10" max="800" step="5"
        default="220" />
    <meta property="primaryRainLength" label="Primary Drop Length (20=0.20)" type="number" min="2" max="80" step="1"
        default="20" />
    <meta property="primaryRainSpacing" label="Primary Drop Spacing (18=0.18)" type="number" min="0" max="50" step="1"
        default="18" />
    <meta property="primaryRainAngle" label="Primary Drop Angle (degrees)" type="number" min="0" max="360" step="1"
        default="90" />
    <meta property="primaryColor" label="Primary Drop Color" type="color" default="#00B3B3" />

    <!-- Secondary rain -->
    <meta property="secondaryRainCount" label="Secondary Drop Count" type="number" min="0" max="60" step="1"
        default="10" />
    <meta property="secondaryRainSpeed" label="Secondary Drop Speed" type="number" min="10" max="800" step="5"
        default="240" />
    <meta property="secondaryRainLength" label="Secondary Drop Length (12=0.12)" type="number" min="2" max="80" step="1"
        default="12" />
    <meta property="secondaryRainSpacing" label="Secondary Drop Spacing (14=0.14)" type="number" min="0" max="50"
        step="1" default="14" />
    <meta property="secondaryRainAngle" label="Secondary Drop Angle (degrees)" type="number" min="0" max="360" step="1"
        default="60" />
    <meta property="secondaryColor" label="Secondary Drop Color" type="color" default="#E6F6FF" />

    <!-- Tertiary rain -->
    <meta property="tertiaryRainCount" label="Tertiary Drop Count" type="number" min="0" max="60" step="1"
        default="10" />
    <meta property="tertiaryRainSpeed" label="Tertiary Drop Speed" type="number" min="10" max="800" step="5"
        default="200" />
    <meta property="tertiaryRainLength" label="Tertiary Drop Length (20=0.20)" type="number" min="2" max="80" step="1"
        default="15" />
    <meta property="tertiaryRainSpacing" label="Tertiary Drop Spacing (18=0.18)" type="number" min="0" max="50" step="1"
        default="18" />
    <meta property="tertiaryRainAngle" label="Tertiary Drop Angle (degrees)" type="number" min="0" max="360" step="1"
        default="120" />
    <meta property="tertiaryColor" label="Tertiary Drop Color" type="color" default="#FFD966" />

    <!-- Visual extras -->
    <meta property="influenceWidth" label="Line Thickness (20=0.020)" type="number" min="5" max="999" step="1"
        default="20" />
    <meta property="useGradient" label="Use Gradient Along Drop" type="boolean" default="true" />
    <meta property="useBlink" label="Blink Drops" type="boolean" default="false" />
    <meta property="primaryRainBlinkPeriod" label="Primary Blink Period (s)" type="number" min="0" max="200" step="1"
        default="28" />
    <meta property="secondaryRainBlinkPeriod" label="Secondary Blink Period (s)" type="number" min="0" max="200"
        step="1" default="28" />
    <meta property="tertiaryRainBlinkPeriod" label="Tertiary Blink Period (s)" type="number" min="0" max="200" step="1"
        default="28" />
    <meta property="maxDrops" label="Max Drops Per Layer" type="number" min="50" max="999" step="5" default="500" />

    <style>
        html,
        body {
            height: 100%;
            margin: 0
        }

        canvas {
            display: block
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="320" height="200"></canvas>

    <script>
        /*
         * PandaFlow Weather - professional refactor for SignalRGB
         * - Central SettingsManager that caches values from <meta> + window
         * - Polling for panel/host changes (SignalRGB sets window.*), but we only
         *   apply those changes when they actually occur (no blind per-frame overwrites)
         * - Presets apply once on change and write to both cache and window so the panel sees them
         * - All runtime code reads from settings.get(...) to avoid race conditions
         *
         * Based on SignalRGB docs: meta tags create controls and supply values via window[property].
         */

        'use strict';

        // ---------- Utilities ----------
        function nowSec() { return Date.now() / 1000; }
        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        function mix(a, b, t) { return a + (b - a) * t; }
        function deg2rad(d) { return d * Math.PI / 180; }
        function rad2deg(r) { return r * 180 / Math.PI; }

        function hexToRgb(hex) {
            if (!hex) return [0, 0, 0];
            hex = ('' + hex).replace('#', '');
            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
            const r = parseInt(hex.slice(0, 2), 16) || 0;
            const g = parseInt(hex.slice(2, 4), 16) || 0;
            const b = parseInt(hex.slice(4, 6), 16) || 0;
            return [r, g, b];
        }

        // ---------- SettingsManager ----------
        class SettingsManager {

            constructor() {
                this.keys = [];            // list of property names from meta
                this.live = {};            // cached values used by runtime
                this.lastWindow = {};      // last observed window value per key
                this.userModified = {};    // flags if the panel/user changed this value
                this.lockedParams = new Set();  // locks de-sync per prop in master (SignalRGB user panel)

                this.presetValues = {};   // remember preset-applied values
                this.overwrittenValue = {}; // values that were in panel before preset

                this._collectMetaDefaults();
            }

            _parseDefault(def) {
                if (def === null || typeof def === 'undefined') return undefined;
                if (def === 'true' || def === 'false') return (def === 'true');
                if (/^#?[0-9a-fA-F]{3}$/.test(def) || /^#?[0-9a-fA-F]{6}$/.test(def)) return def;
                if (!isNaN(parseFloat(def)) && isFinite(def)) return parseFloat(def);
                return def;
            }

            _collectMetaDefaults() {
                const metas = document.querySelectorAll('meta[property]');
                metas.forEach(m => {
                    const name = m.getAttribute('property');
                    if (!name) return;
                    if (this.keys.indexOf(name) === -1) this.keys.push(name);
                    const def = m.getAttribute('default');
                    const parsed = this._parseDefault(def);

                    // Prefer existing host-provided window[name] if present (SignalRGB may set it before script runs)
                    const hostVal = (typeof window[name] !== 'undefined') ? window[name] : undefined;
                    const initial = (typeof hostVal !== 'undefined') ? hostVal : parsed;

                    this.live[name] = initial;
                    this.lastWindow[name] = initial;
                    this.userModified[name] = false;

                    // make sure host sees something
                    try { window[name] = initial; } catch (e) { /* ignore */ }
                });

                // also ensure we manage some commonly-used runtime keys even if meta not present
                const extra = [
                    'preset', 'presetIntensity', 'themeColor', 'primaryColor', 'secondaryColor', 'tertiaryColor',
                    'primaryRainCount', 'secondaryRainCount', 'tertiaryRainCount',
                    'primaryRainSpeed', 'secondaryRainSpeed', 'tertiaryRainSpeed',
                    'primaryRainLength', 'secondaryRainLength', 'tertiaryRainLength',
                    'primaryRainSpacing', 'secondaryRainSpacing', 'tertiaryRainSpacing',
                    'primaryRainAngle', 'secondaryRainAngle', 'tertiaryRainAngle',
                    'primaryShape', 'secondaryShape', 'tertiaryShape',
                    'objectScale', 'maxDrops', 'useBlink', 'useGradient',
                    'breathingCycleSec', 'breathingMin', 'breathingMax',
                    'audioReactive', 'audioSource', 'audioFloor', 'audioCeiling', 'audioSensitivity', 'audioAttackMs', 'audioReleaseMs', 'audioMix'
                ];
                extra.forEach(k => {
                    if (this.keys.indexOf(k) === -1) this.keys.push(k);
                    if (typeof this.live[k] === 'undefined') {
                        const hostVal = (typeof window[k] !== 'undefined') ? window[k] : undefined;
                        this.live[k] = hostVal;
                        this.lastWindow[k] = hostVal;
                        this.userModified[k] = false;
                    }
                });
            }

            // set via script/preset (source = 'preset'|'script'|'user')
            set(name, value, source = 'script') {
                // Preset/script writes bypass lock (they *create* the lock)
                if (source !== 'preset' && this.lockedParams.has(name)) {
                    return this.live[name]; // ignore external writes if locked
                }
                this.live[name] = value;
                this.userModified[name] = (source === 'user');
                this.lastWindow[name] = value;
                try { window[name] = value; } catch (e) { /* ignore environments that lock window */ }
                return value;
            }

            // keep locked values in charge
            enforceLocks() {
                for (const k of this.lockedParams) {
                    try { window[k] = this.live[k]; } catch (e) { }
                }
            }

            // read cached value (fallback to window if completely missing)
            get(name, fallback) {
                if (typeof this.live[name] !== 'undefined') return this.live[name];
                if (typeof window[name] !== 'undefined') return window[name];
                return fallback;
            }

            // poll host/window to detect user/panel changes
            poll() {
                for (const k of this.keys) {
                    const winV = (typeof window[k] !== 'undefined') ? window[k] : undefined;
                    const lastV = this.lastWindow[k];

                    if (!this._equal(winV, lastV)) {
                        if (this.lockedParams.has(k)) {
                            const presetV = (this.presetValue && k in this.presetValue) ? this.presetValue[k] : undefined;
                            const overwrittenV = (this.overwrittenValue && k in this.overwrittenValue) ? this.overwrittenValue[k] : undefined;

                            if (presetV !== undefined && this._equal(winV, presetV)) {
                                // still at preset value
                                this.lastWindow[k] = winV;
                            } else if (overwrittenV !== undefined && this._equal(winV, overwrittenV)) {
                                // panel resync, restore preset
                                if (presetV !== undefined) {
                                    try { window[k] = presetV; } catch (e) { }
                                    this.lastWindow[k] = presetV;
                                }
                            } else if (presetV !== undefined) {
                                // user really touched slider → unlock
                                this.lockedParams.delete(k);
                                this.live[k] = winV;
                                this.lastWindow[k] = winV;
                                this.userModified[k] = true;
                                console.debug(`[Settings] Unlocked ${k}, user changed to ${winV}`);
                            } else {
                                // no preset value recorded → just unlock silently
                                this.lockedParams.delete(k);
                            }
                        } else {
                            // not locked → normal update
                            this.live[k] = winV;
                            this.lastWindow[k] = winV;
                            this.userModified[k] = true;
                        }
                    }
                }
            }



            _equal(a, b) {
                if (typeof a === 'number' && typeof b === 'number' && isFinite(a) && isFinite(b)) return Math.abs(a - b) < 1e-9;
                return a === b;
            }

            // push cached values to window (safe sync)
            syncToWindow() {
                for (const k of this.keys) {
                    try { window[k] = this.live[k]; } catch (e) { /* ignore */ }
                }
            }

            // helper to mark a param as user-changed
            markUserChanged(name) { this.userModified[name] = true; }

            // Simple heuristic: if the window changed away from preset value, treat as slider move
            _isUserInteraction(name, winV, lastV) {
                console.debug(`[Settings] Unlocking ${name}, user changed from ${lastV} → ${winV}`);
                return true; // In SignalRGB, any change while locked should mean user touched it
            }
        }

        // create settings manager instance
        const Settings = new SettingsManager();

        // convenience wrapper matching earlier setParam signature
        function setParam(name, value) {
            return Settings.set(name, value, 'preset');
        }

        // ---------- Canvas setup ----------
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let canvasScaleFactor = 1;
        function applyCanvasScale() {
            const cssW = parseInt(canvas.getAttribute('width') || 320, 10);
            const cssH = parseInt(canvas.getAttribute('height') || 200, 10);
            const canvasScale = Number(Settings.get('objectScale', 100)) || 100;
            canvasScaleFactor = canvasScale / 100;
            canvas.width = Math.max(1, Math.round(cssW * canvasScaleFactor));
            canvas.height = Math.max(1, Math.round(cssH * canvasScaleFactor));
            canvas.style.width = cssW + 'px';
            canvas.style.height = cssH + 'px';
        }
        applyCanvasScale();
        let W = canvas.width, H = canvas.height;
        window.addEventListener('resize', () => { applyCanvasScale(); W = canvas.width; H = canvas.height; });

        // ---------- Runtime state ----------
        let lastTime = nowSec();
        let primaryDrops = [], secondaryDrops = [], tertiaryDrops = [];
        let audioEnv = 0;
        let lightningTimer = 0;
        let pulsarBursts = [];
        let pulsarLastSpawn = 0;
        let lastPreset = Settings.get('preset', undefined);

        // ---------- Helpers re: shapes/directions ----------
        function makeDir(angleDeg) {
            const rad = deg2rad(Number(angleDeg) || 0);
            const vx = Math.cos(rad);
            const vy = Math.sin(rad);
            const len = Math.hypot(vx, vy) || 1;
            return { vx: vx / len, vy: vy / len };
        }

        function spawnDrop(layer, params, colorRGB, angleDeg, scaleFactor, shape, blinkPeriod) {
            const dir = makeDir(angleDeg);
            const vx = dir.vx, vy = dir.vy;

            let px, py;
            if (Math.abs(vx) > Math.abs(vy)) {
                px = (vx > 0) ? -10 : W + 10;
                py = Math.random() * H;
            } else {
                px = Math.random() * W;
                py = (vy > 0) ? -10 : H + 10;
            }

            const baseSpeed = Number(params.speed) * scaleFactor;
            const speedVariation = 0.8 + Math.random() * 0.4;
            const speedPxPerSec = baseSpeed * Math.max(W, H);

            const drop = {
                x: px, y: py,
                vx: vx * speedPxPerSec * speedVariation,
                vy: vy * speedPxPerSec * speedVariation,
                len: params.len * Math.min(W, H) * scaleFactor,
                colorRGB,
                shape: shape,
                life: 1.0,
                phase: Math.random(),
                blinkPeriod: blinkPeriod || 0
            };

            layer.push(drop);
        }

        function updateLayer(layer, dt, scaleFactor, drift) {
            for (const d of layer) {
                if (drift) {
                    d.vx += drift.x * W * dt * scaleFactor + (drift.jitter * (Math.random() - 0.5)) * dt * 100;
                }
                d.x += d.vx * dt;
                d.y += d.vy * dt;
            }
            const objectScaleFactor = Number(Settings.get('objectScale', 100)) / 100;
            const cullMargin = 100 * objectScaleFactor;
            for (let i = layer.length - 1; i >= 0; i--) {
                const d = layer[i];
                if (d.x < -cullMargin || d.x > W + cullMargin || d.y < -cullMargin || d.y > H + cullMargin) {
                    layer.splice(i, 1);
                }
            }
        }

        function ensurePopulation(layer, desiredCount, params, colorRGB, angleDeg, maxDrops, scaleFactor, shape, blinkPeriod) {
            while (layer.length < Math.min(Number(desiredCount) || 0, Number(maxDrops) || 0)) {
                spawnDrop(layer, params, colorRGB, angleDeg, scaleFactor, shape, blinkPeriod);
            }
        }

        function blinkForDrop(d, t) {
            if (!d.blinkPeriod || d.blinkPeriod <= 0) return 1.0;
            const ph = (t / (d.blinkPeriod / 100) + d.phase) % 1;
            return (ph < 0.5) ? 1.0 : 0.35;
        }

        // ---------- Audio helpers (SignalRGB exposes getAudioLevel/getAudioRMS) ----------
        function verifyAudioAPI() {
            if (Settings.get('audioReactive')) {
                const hasAPI = (typeof getAudioLevel === 'function') || (typeof getAudioRMS === 'function');
                if (!hasAPI) {
                    console.warn('[PandaFlow] Audio-reactive disabled: getAudioLevel/getAudioRMS API not available.');
                    Settings.set('audioReactive', false, 'script');
                }
            }
        }

        function queryAudioLevel(source) {
            try {
                if (typeof getAudioLevel === 'function') return clamp(getAudioLevel(source), 0, 1);
                if (typeof getAudioRMS === 'function') return clamp(getAudioRMS(source), 0, 1);
            } catch (e) { }
            return 0;
        }

        function smoothEnvelope(prev, target, dt, attackMs, releaseMs) {
            const a = clamp(attackMs / 1000, 0.001, 2.0);
            const r = clamp(releaseMs / 1000, 0.001, 2.0);
            const coeff = (target > prev) ? Math.exp(-dt / a) : Math.exp(-dt / r);
            return target + (prev - target) * coeff;
        }

        // ---------- Pulsar bursts & static stars ----------
        function spawnPulsarBurst(kind) {
            const posX = W / 2, posY = H / 2;
            const colorRGB = hexToRgb(String(Settings.get('primaryColor') || '#FFFFFF'));
            const burst = { x: posX, y: posY, radius: 0.02, colorRGB, life: 1.0, maxLife: 1.0 };
            pulsarBursts.push(burst);
        }
        function updatePulsarBursts(dt) {
            for (let i = pulsarBursts.length - 1; i >= 0; i--) {
                const b = pulsarBursts[i];
                b.life -= dt;
                b.radius += dt * 0.4;
                if (b.life <= 0) pulsarBursts.splice(i, 1);
            }
        }
        function drawPulsarBursts() {
            for (const burst of pulsarBursts) {
                const [r, g, b] = burst.colorRGB;
                const alpha = (burst.life / burst.maxLife);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.lineWidth = Math.max(1, Math.round(0.03 * (W + H) / 2));
                ctx.beginPath();
                ctx.arc(W / 2, H / 2, burst.radius * Math.max(W, H), 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        let staticStars = [];
        function spawnStaticStars(count) {
            staticStars = [];
            for (let i = 0; i < count; i++) staticStars.push({ x: Math.random() * W, y: Math.random() * H, twinklePhase: Math.random(), life: Math.random() * Number(Settings.get('staticStarLifespan', 8) || 8) });
        }
        function updateStaticStars(dt) {
            for (let s of staticStars) {
                s.twinklePhase += dt * 0.5; if (s.twinklePhase > 1) s.twinklePhase -= 1;
                s.life += dt; if (s.life >= Number(Settings.get('staticStarLifespan', 8) || 8)) { s.x = Math.random() * W; s.y = Math.random() * H; s.twinklePhase = Math.random(); s.life = 0; }
            }
        }
        function drawStaticStars() {
            for (let s of staticStars) {
                const alpha = 0.5 + 0.5 * Math.sin(s.twinklePhase * Math.PI * 2);
                let starRGB;
                switch (String(Settings.get('staticStarColorSource', 'Custom'))) {
                    case 'Theme': starRGB = hexToRgb(String(Settings.get('themeColor') || '#000000')); break;
                    case 'Primary': starRGB = hexToRgb(String(Settings.get('primaryColor') || '#FFFFFF')); break;
                    case 'Secondary': starRGB = hexToRgb(String(Settings.get('secondaryColor') || '#FFFFFF')); break;
                    case 'Tertiary': starRGB = hexToRgb(String(Settings.get('tertiaryColor') || '#FFFFFF')); break;
                    case 'Random': starRGB = [Math.random() * 255, Math.random() * 255, Math.random() * 255]; break;
                    default: starRGB = hexToRgb(String(Settings.get('staticStarCustomColor') || '#FFFFFF')); break;
                }
                ctx.fillStyle = `rgba(${starRGB[0]},${starRGB[1]},${starRGB[2]},${alpha})`;
                ctx.beginPath(); ctx.arc(s.x, s.y, Number(Settings.get('staticStarSize', 2) || 2), 0, Math.PI * 2); ctx.fill();
            }
        }

        // ---------- Draw drops ----------
        function drawDrop(d, blink) {
            const alpha = clamp(d.life, 0, 1) * blink;
            const [r, g, b] = d.colorRGB;
            ctx.lineCap = 'round';

            const widthFactor = (Number(Settings.get('influenceWidth', 20)) / 100) * ((W + H) / 200);
            const ang = Math.atan2(d.vy, d.vx);
            const objectScaleFactor = Number(Settings.get('objectScale', 100)) / 100;
            const scaleLen = (d.len || 10) * widthFactor;

            switch (d.shape) {
                case 'Dot':
                    ctx.beginPath(); ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`; ctx.arc(d.x, d.y, scaleLen * 0.15, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'Star': {
                    const ang = Math.atan2(d.vy, d.vx);
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang);
                    ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.lineWidth = Math.max(1, scaleLen * 0.05);

                    ctx.beginPath(); ctx.moveTo(0, -scaleLen * 0.15); ctx.lineTo(scaleLen * 0.15, 0); ctx.lineTo(0, scaleLen * 0.15); ctx.lineTo(-scaleLen * 0.15, 0); ctx.closePath(); ctx.stroke();

                    const armLen = scaleLen * 0.25; const armWidth = scaleLen * 0.1;
                    ctx.beginPath(); ctx.moveTo(-armWidth, -scaleLen * 0.15); ctx.lineTo(armWidth, -scaleLen * 0.15); ctx.lineTo(0, -scaleLen * 0.15 - armLen); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(-armWidth, scaleLen * 0.15); ctx.lineTo(armWidth, scaleLen * 0.15); ctx.lineTo(0, scaleLen * 0.15 + armLen); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(-scaleLen * 0.15, -armWidth); ctx.lineTo(-scaleLen * 0.15, armWidth); ctx.lineTo(-scaleLen * 0.15 - armLen, 0); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(scaleLen * 0.15, -armWidth); ctx.lineTo(scaleLen * 0.15, armWidth); ctx.lineTo(scaleLen * 0.15 + armLen, 0); ctx.closePath(); ctx.fill();
                    ctx.restore();
                } break;
                case 'Sand':
                    ctx.beginPath(); ctx.fillStyle = `rgba(${r},${g},${b},${alpha * 0.7})`; ctx.arc(d.x, d.y, scaleLen * 0.1, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'WaterDroplet':
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang - Math.PI / 2); ctx.scale(scaleLen / 10, scaleLen / 10); ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(-3, -6, 0, -10); ctx.quadraticCurveTo(3, -6, 0, 0); ctx.fill(); ctx.restore();
                    break;
                case 'WaterDropletStorm':
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang - Math.PI / 2); ctx.scale(scaleLen / 10, scaleLen / 10); ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(-3, -5, 0, -25); ctx.quadraticCurveTo(3, -4, 0, 0); ctx.fill(); ctx.restore();
                    break;
                case 'Meteor': {
                    const ang = Math.atan2(d.vy, d.vx);
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang);
                    const scaleLenM = Number(Settings.get('meteorSize', 15)) * objectScaleFactor;
                    ctx.scale(scaleLenM / 10, scaleLenM / 10);
                    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.beginPath();
                    const segments = 5 + Math.floor(Math.random() * 3);
                    const baseRadius = scaleLenM * 0.3;
                    const spin = d.phase * Math.PI * 2;
                    for (let i = 0; i < segments; i++) { const a = spin + (i / segments) * Math.PI * 2; const radius = baseRadius * (0.85 + Math.random() * 0.3); const x = Math.cos(a) * radius; const y = Math.sin(a) * radius; if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); }
                    ctx.closePath(); ctx.fill();
                    const grad = ctx.createLinearGradient(-scaleLenM * 3.75, 0, 0, 0); grad.addColorStop(0, `rgba(${r},${g},${b},0)`); grad.addColorStop(1, `rgba(${r},${g},${b},${alpha})`);
                    ctx.strokeStyle = grad; ctx.lineWidth = Math.max(1, scaleLenM * 0.33); ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(-scaleLenM * 3.75, 0); ctx.lineTo(-scaleLenM * 0.25, 0); ctx.stroke(); ctx.restore();
                } break;
                case 'Snow': {
                    const ang = Math.atan2(d.vy, d.vx);
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang);
                    const widthFactor = (Number(Settings.get('influenceWidth', 20)) / 100) * ((W + H) / 200);
                    const scaleLenS = (d.len || 10) * widthFactor * objectScaleFactor;
                    ctx.scale(scaleLenS / 10, scaleLenS / 10);
                    const twinkle = Math.sin((performance.now() / 1000 + d.phase) * 8) * 0.2; ctx.rotate(twinkle);
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(0, 5); ctx.moveTo(-3, -2); ctx.lineTo(3, 2); ctx.moveTo(-3, 2); ctx.lineTo(3, -2);
                    ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`; ctx.lineWidth = Math.max(1, scaleLenS * 0.12); ctx.lineCap = 'round'; ctx.stroke(); ctx.restore();
                } break;
                case 'StarShip': {
                    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(ang + Math.PI / 2);
                    const sl = Number(Settings.get('starShipSize', 14)) * objectScaleFactor; ctx.scale(sl / 10, sl / 10);
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(4, 4); ctx.arc(0, 4, 4, 0, Math.PI, true); ctx.lineTo(-4, 4); ctx.closePath(); ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`; ctx.fill(); ctx.restore();
                } break;
                default: {
                    const vx = d.vx, vy = d.vy;
                    const ang = Math.atan2(vy, vx);
                    const len = (d.len * objectScaleFactor) || (10 * objectScaleFactor);
                    const sx = -Math.cos(ang) * (len * 0.5); const sy = -Math.sin(ang) * (len * 0.5);
                    const ex = Math.cos(ang) * (len * 0.5); const ey = Math.sin(ang) * (len * 0.5);
                    ctx.beginPath(); const w = Math.max(1, Math.round((Number(Settings.get('influenceWidth', 20)) / 100) * ((W + H) / 200) * objectScaleFactor)); ctx.lineWidth = w; ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
                    ctx.moveTo(d.x + sx, d.y + sy); ctx.lineTo(d.x + ex, d.y + ey); ctx.stroke();
                } break;
            }
        }

        // ---------- Apply Preset + Lock ----------
        function applyPresetStatic() {
            Settings.lockedParams.clear(); // reset all locks

            const pi = Number(Settings.get('presetIntensity', 100)) || 100;
            const primAngleCurrent = Number(Settings.get('primaryRainAngle', 90)) || 90;
            const secAngleCurrent = Number(Settings.get('secondaryRainAngle', 60)) || 60;

            function lockSet(name, value) {

                // remember what was there before preset overwrote it
                Settings.overwrittenValue[name] = (typeof window[name] !== 'undefined') ? window[name] : null;
                Settings.presetValues[name] = value;   // remember preset value

                Settings.set(name, value, 'preset');
                Settings.lockedParams.add(name);
                console.debug("[LockSet]", name, "preset:", value, "overwritten:", Settings.overwrittenValue[name]);
            }

            switch (String(Settings.get('preset', 'Custom'))) {
                case 'Storm':
                    lockSet('primaryShape', 'WaterDropletStorm');
                    lockSet('secondaryShape', 'WaterDropletStorm');
                    lockSet('tertiaryShape', 'WaterDropletStorm');
                    lockSet('primaryRainCount', Math.round(40 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(35 * (pi / 100)));
                    lockSet('primaryRainSpeed', 500 * (pi / 100));
                    lockSet('secondaryRainSpeed', 480 * (pi / 100));
                    lockSet('primaryRainLength', 22);
                    lockSet('secondaryRainLength', 18);
                    lockSet('primaryRainSpacing', 12);
                    lockSet('secondaryRainSpacing', 12);
                    lockSet('tertiaryRainCount', 80);
                    lockSet('tertiaryRainSpeed', 500);
                    lockSet('tertiaryRainLength', 8);
                    lockSet('tertiaryRainSpacing', 15);
                    lockSet('tertiaryRainAngle', primAngleCurrent + 20);
                    lockSet('tertiaryColor', '#FFD966');
                    lockSet('breathingCycleSec', 400);
                    lockSet('breathingMin', 8);
                    lockSet('breathingMax', 95);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Calm':
                    lockSet('primaryShape', 'Line');
                    lockSet('secondaryShape', 'Dot');
                    lockSet('tertiaryShape', 'Star');
                    lockSet('primaryRainCount', Math.round(8 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(6 * (pi / 100)));
                    lockSet('primaryRainSpeed', 120 * (pi / 100));
                    lockSet('secondaryRainSpeed', 100 * (pi / 100));
                    lockSet('primaryRainLength', 18);
                    lockSet('secondaryRainLength', 14);
                    lockSet('primaryRainSpacing', 22);
                    lockSet('secondaryRainSpacing', 24);
                    lockSet('tertiaryRainCount', 20);
                    lockSet('tertiaryRainSpeed', 120);
                    lockSet('tertiaryRainLength', 25);
                    lockSet('tertiaryRainSpacing', 20);
                    lockSet('tertiaryRainAngle', Number(Settings.get('secondaryRainAngle', 60)) - 15);
                    lockSet('tertiaryColor', '#B3E5FC');
                    lockSet('breathingCycleSec', 1000);
                    lockSet('breathingMin', 20);
                    lockSet('breathingMax', 50);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Waves':
                    lockSet('primaryShape', 'Dot');
                    lockSet('secondaryShape', 'Dot');
                    lockSet('tertiaryShape', 'Dot');
                    lockSet('primaryRainCount', Math.round(16 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(16 * (pi / 100)));
                    lockSet('primaryRainSpeed', 200 * (pi / 100));
                    lockSet('secondaryRainSpeed', 200 * (pi / 100));
                    lockSet('primaryRainLength', 20);
                    lockSet('secondaryRainLength', 20);
                    lockSet('primaryRainSpacing', 16);
                    lockSet('secondaryRainSpacing', 16);
                    lockSet('tertiaryRainCount', 40);
                    lockSet('tertiaryRainSpeed', 180);
                    lockSet('tertiaryRainLength', 15);
                    lockSet('tertiaryRainSpacing', 18);
                    lockSet('tertiaryRainAngle', (primAngleCurrent + 180) % 360);
                    lockSet('tertiaryColor', '#4DD0E1');
                    lockSet('breathingCycleSec', 800);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Rain':
                    lockSet('primaryShape', 'WaterDroplet');
                    lockSet('secondaryShape', 'WaterDroplet');
                    lockSet('tertiaryShape', 'WaterDroplet');
                    lockSet('primaryRainCount', Math.round(20 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(20 * (pi / 100)));
                    lockSet('primaryRainSpeed', 250 * (pi / 100));
                    lockSet('secondaryRainSpeed', 230 * (pi / 100));
                    lockSet('primaryRainLength', 16);
                    lockSet('secondaryRainLength', 14);
                    lockSet('primaryRainSpacing', 18);
                    lockSet('secondaryRainSpacing', 18);
                    lockSet('tertiaryRainCount', 60);
                    lockSet('tertiaryRainSpeed', 200);
                    lockSet('tertiaryRainLength', 12);
                    lockSet('tertiaryRainSpacing', 16);
                    lockSet('tertiaryRainAngle', primAngleCurrent);
                    lockSet('tertiaryColor', '#90CAF9');
                    lockSet('breathingCycleSec', 700);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Snow':
                    lockSet('primaryShape', 'Snow');
                    lockSet('secondaryShape', 'Snow');
                    lockSet('tertiaryShape', 'Snow');
                    lockSet('primaryRainCount', Math.round(24 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(24 * (pi / 100)));
                    lockSet('primaryRainSpeed', 80 * (pi / 100));
                    lockSet('secondaryRainSpeed', 70 * (pi / 100));
                    lockSet('primaryRainLength', 6);
                    lockSet('secondaryRainLength', 6);
                    lockSet('primaryRainSpacing', 10);
                    lockSet('secondaryRainSpacing', 10);
                    lockSet('tertiaryRainCount', 30);
                    lockSet('tertiaryRainSpeed', 80);
                    lockSet('tertiaryRainLength', 20);
                    lockSet('tertiaryRainSpacing', 25);
                    lockSet('tertiaryRainAngle', Number(Settings.get('secondaryRainAngle', 60)));
                    lockSet('tertiaryColor', '#FFF8E1');
                    lockSet('breathingCycleSec', 1200);
                    lockSet('breathingMin', 25);
                    lockSet('breathingMax', 55);
                    lockSet('useBlink', true);
                    lockSet('useGradient', false);
                    break;

                case 'Sandstorm':
                    lockSet('primaryShape', 'Sand');
                    lockSet('secondaryShape', 'Sand');
                    lockSet('tertiaryShape', 'Sand');
                    lockSet('primaryRainCount', Math.round(50 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(45 * (pi / 100)));
                    lockSet('primaryRainSpeed', 400 * (pi / 100));
                    lockSet('secondaryRainSpeed', 380 * (pi / 100));
                    lockSet('primaryRainLength', 15);
                    lockSet('secondaryRainLength', 12);
                    lockSet('primaryRainSpacing', 10);
                    lockSet('secondaryRainSpacing', 10);
                    lockSet('tertiaryRainCount', 70);
                    lockSet('tertiaryRainSpeed', 400);
                    lockSet('tertiaryRainLength', 10);
                    lockSet('tertiaryRainSpacing', 14);
                    lockSet('tertiaryRainAngle', primAngleCurrent + 10);
                    lockSet('tertiaryColor', '#D7B899');
                    lockSet('breathingCycleSec', 500);
                    lockSet('breathingMin', 15);
                    lockSet('breathingMax', 65);
                    lockSet('useBlink', true);
                    lockSet('useGradient', true);
                    break;

                case 'Pulsar':
                case 'Pulsar2':
                    lockSet('primaryShape', 'Star');
                    lockSet('secondaryShape', 'Meteor');
                    lockSet('tertiaryShape', 'StarShip');
                    lockSet('primaryRainCount', 40);
                    lockSet('primaryRainSpeed', 500);
                    lockSet('primaryRainLength', 15);
                    lockSet('primaryRainSpacing', 20);
                    lockSet('primaryRainAngle', 90);
                    lockSet('primaryColor', '#FFFFFF');
                    lockSet('secondaryRainCount', 20);
                    lockSet('secondaryRainSpeed', 300);
                    lockSet('secondaryRainLength', 20);
                    lockSet('secondaryRainSpacing', 25);
                    lockSet('secondaryRainAngle', 90);
                    lockSet('secondaryColor', '#80D8FF');
                    lockSet('tertiaryRainCount', 5);
                    lockSet('tertiaryRainSpeed', 700);
                    lockSet('tertiaryRainLength', 12);
                    lockSet('tertiaryRainSpacing', 18);
                    lockSet('tertiaryRainAngle', Number(Settings.get('primaryRainAngle', 90)));
                    lockSet('tertiaryColor', '#FFEB3B');
                    lockSet('breathingCycleSec', 250);
                    lockSet('breathingMin', 5);
                    lockSet('breathingMax', 100);
                    lockSet('useBlink', false);
                    lockSet('useGradient', true);
                    break;

                case 'Stars':
                    lockSet('primaryShape', 'Star');
                    lockSet('secondaryShape', 'Meteor');
                    lockSet('tertiaryShape', 'StarShip');
                    lockSet('primaryRainCount', Math.round(6 * (pi / 100)));
                    lockSet('secondaryRainCount', Math.round(4 * (pi / 100)));
                    lockSet('primaryRainSpeed', 500 * (pi / 100));
                    lockSet('secondaryRainSpeed', 480 * (pi / 100));
                    lockSet('primaryRainLength', 12);
                    lockSet('secondaryRainLength', 10);
                    lockSet('primaryRainSpacing', 30);
                    lockSet('secondaryRainSpacing', 30);
                    lockSet('tertiaryRainCount', 15);
                    lockSet('tertiaryRainSpeed', 300);
                    lockSet('tertiaryRainLength', 8);
                    lockSet('tertiaryRainSpacing', 20);
                    lockSet('tertiaryRainAngle', Number(Settings.get('secondaryRainAngle', 60)));
                    lockSet('tertiaryColor', '#FFF59D');
                    lockSet('breathingCycleSec', 1500);
                    lockSet('breathingMin', 5);
                    lockSet('breathingMax', 20);
                    lockSet('useBlink', true);
                    lockSet('useGradient', true);
                    break;

                default:
                    // Custom or unknown - keep existing cached values
                    break;
            }

            // ensure window has up-to-date values
            Settings.syncToWindow();
        }

        // ---------- Main loop (clean) ----------
        function update() {
            try {
                const now = nowSec();
                let dt = clamp(now - lastTime, 0, 0.05);
                lastTime = now;

                // poll host for changes (panel/user) - this updates cache only when something changed
                Settings.poll();
                // re-apply locked values so presets stay in charge
                Settings.enforceLocks();

                // check preset changes
                const presetNow = String(Settings.get('preset', 'Custom'));
                const presetChanged = (lastPreset !== presetNow);
                if (presetChanged) {
                    // presets set values once and sync them to window so panel sees the new values
                    applyPresetStatic();

                    // handle pulsar immediate spawn
                    if (presetNow === 'Pulsar' || presetNow === 'Pulsar2') { spawnPulsarBurst(presetNow); pulsarLastSpawn = now; }

                    if (presetNow === 'Stars') spawnStaticStars(Number(Settings.get('staticStarCount', 50) || 50));

                    lastPreset = presetNow;
                }

                // verify audio availability only when preset changes or when audioReactive turned on
                verifyAudioAPI();

                // read values from Settings for the rest of the loop
                const objectScaleFactor = Number(Settings.get('objectScale', 100)) / 100;
                const maxDrops = Number(Settings.get('maxDrops', 500)) || 500;

                // breathing factor
                const baseRGB = (() => {
                    const src = String(Settings.get('breathingColorSource', 'Theme'));
                    switch (src) {
                        case 'Primary': return hexToRgb(String(Settings.get('primaryColor') || '#000000'));
                        case 'Secondary': return hexToRgb(String(Settings.get('secondaryColor') || '#000000'));
                        case 'Tertiary': return hexToRgb(String(Settings.get('tertiaryColor') || '#000000'));
                        case 'Random': return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
                        case 'Custom': return hexToRgb(String(Settings.get('breathingCustomColor') || '#FFFFFF'));
                        default: return hexToRgb(String(Settings.get('themeColor') || '#000000'));
                    }
                })();

                const fBreath = (function () { const cyc = Number(Settings.get('breathingCycleSec', 750)) || 750; const minV = Number(Settings.get('breathingMin', 15)) / 100 || 0.15; const maxV = Number(Settings.get('breathingMax', 80)) / 100 || 0.8; const phase = (now % (cyc / 100)) / (cyc / 100); const s = 0.5 - 0.5 * Math.cos(phase * Math.PI * 2); const p = Math.pow(s, 1 / 2.2); return mix(minV, maxV, p); })();

                let f = fBreath;
                if (Settings.get('audioReactive')) {
                    let lvl = queryAudioLevel(String(Settings.get('audioSource', 'Microphone')));
                    lvl = clamp(lvl * (Number(Settings.get('audioSensitivity', 100)) / 100), 0, 1);
                    const win = (Number(Settings.get('audioCeiling', 35)) / 100) - (Number(Settings.get('audioFloor', 5)) / 100);
                    const norm = win <= 0 ? 0 : clamp((lvl - (Number(Settings.get('audioFloor', 5)) / 100)) / win, 0, 1);
                    audioEnv = smoothEnvelope(audioEnv, norm, dt, Number(Settings.get('audioAttackMs', 30)), Number(Settings.get('audioReleaseMs', 180)));
                    const fAudio = mix(Number(Settings.get('breathingMin', 15)) / 100, Number(Settings.get('breathingMax', 80)) / 100, audioEnv);
                    f = mix(fBreath, fAudio, Number(Settings.get('audioMix', 55)) / 100);
                }

                if (lightningTimer > 0) lightningTimer = Math.max(0, lightningTimer - dt);

                // behavior & per-preset dynamics (angles, gusts, lightning overlay)
                const behavior = (function () {
                    const base = { primAngle: Number(Settings.get('primaryRainAngle', 90)), secAngle: Number(Settings.get('secondaryRainAngle', 60)), tertAngle: Number(Settings.get('tertiaryRainAngle', 120)), lightningOverlay: 0, drift: null, blurAmount: 0 };
                    const preset = String(Settings.get('preset', 'Custom'));
                    if (preset === 'Storm') {
                        const gustAmp = 3 + 2 * ((Number(Settings.get('presetIntensity', 100)) / 100) - 1);
                        const gust = (Math.sin(now * 1.7) + Math.sin(now * 2.3 + 1.1)) * gustAmp;
                        base.primAngle = Number(Settings.get('primaryRainAngle', 90)) + gust;
                        base.secAngle = Number(Settings.get('secondaryRainAngle', 60)) - gust * 0.7;
                        if (lightningTimer <= 0 && Math.random() < (Number(Settings.get('stormLightningChance', 100)) / 10000) * (Number(Settings.get('presetIntensity', 100)) / 100)) {
                            lightningTimer = 0.20 + Math.random() * 0.15;
                            if (Math.random() < 0.2) setTimeout(() => { lightningTimer = 0.15; }, 150);
                        }
                        if (lightningTimer > 0) base.lightningOverlay = clamp(lightningTimer / 0.35, 0, 1);
                        if (Math.random() < (Number(Settings.get('stormMicroGustChance', 20)) / 10000) * (Number(Settings.get('presetIntensity', 100)) / 100)) {
                            base.primAngle += (Math.random() < 0.5 ? -10 : 10);
                            base.secAngle += (Math.random() < 0.5 ? -7 : 7);
                        }
                        base.blurAmount = 1;
                    } else if (preset === 'Calm') {
                        base.primAngle = 90; base.secAngle = 90;
                    } else if (preset === 'Waves') {
                        const swayAmp = 20 * (Number(Settings.get('presetIntensity', 100)) / 100);
                        const sway = Math.sin(now * 0.8) * swayAmp;
                        base.primAngle = 60 + sway; base.secAngle = 120 - sway;
                    } else if (preset === 'Rain') { base.primAngle = 90; base.secAngle = 90; base.blurAmount = 1; }
                    else if (preset === 'Snow') { const driftX = 0.05 * (Math.sin(now * 0.7) + 0.5 * Math.sin(now * 1.1 + 2.1)); base.drift = { x: driftX, jitter: 0.25 }; const sway = Math.sin(now * 0.6) * 10; base.primAngle = 90 + sway; base.secAngle = 90 - sway; base.blurAmount = 0.5; }
                    else if (preset === 'Sandstorm') { const gustAmp = 8 + 4 * ((Number(Settings.get('presetIntensity', 100)) / 100) - 1); const gust = Math.sin(now * 1.3) * gustAmp; base.primAngle = 15 + gust; base.secAngle = 165 - gust; const phase = now * 5.0; const haze = 0.6 * Math.sin(phase) + 0.4 * Math.sin(phase * 0.53 + 1.7) + 0.3 * Math.sin(phase * 0.37 + 0.3); base.lightningOverlay = clamp(0.08 + 0.07 * haze * (Number(Settings.get('presetIntensity', 100)) / 100), 0, 0.3); if (Math.random() < (Number(Settings.get('sandstormGustBurstChance', 30)) / 10000) * (Number(Settings.get('presetIntensity', 100)) / 100)) { base.primAngle += (Math.random() < 0.5 ? -15 : 15); base.secAngle += (Math.random() < 0.5 ? -15 : 15); base.tertAngle += (Math.random() < 0.5 ? -15 : 15); } base.blurAmount = 0.5; }
                    else if (preset === 'Pulsar') { const phase = (now % (Number(Settings.get('breathingCycleSec', 750)) / 100)) / (Number(Settings.get('breathingCycleSec', 750)) / 100); if (phase < 0.05 && now - pulsarLastSpawn > (Number(Settings.get('breathingCycleSec', 750)) / 100) * 0.5) { pulsarLastSpawn = now; spawnPulsarBurst('Pulsar'); } }
                    else if (preset === 'Pulsar2') { const phase = (now % (Number(Settings.get('breathingCycleSec', 750)) / 100)) / (Number(Settings.get('breathingCycleSec', 750)) / 100); if (phase < 0.05 && now - pulsarLastSpawn > (Number(Settings.get('breathingCycleSec', 750)) / 100) * 0.5) { pulsarLastSpawn = now; const rings = 2 + Math.floor(Math.random() * 2); for (let i = 0; i < rings; i++) { setTimeout(() => spawnPulsarBurst('Pulsar2'), i * 200); } } }
                    else if (preset === 'Stars') { base.primAngle = 45 + (Math.random() * 10 - 5); base.secAngle = 225 + (Math.random() * 10 - 5); if (Math.random() < (Number(Settings.get('starsMeteorShowerChance', 15)) / 10000) * (Number(Settings.get('presetIntensity', 100)) / 100)) base.meteorShower = true; }
                    return base;
                })();

                const overlay = behavior.lightningOverlay || 0;
                const overlayRGB = [255, 240, 200];

                let bgR = baseRGB[0] * f; let bgG = baseRGB[1] * f; let bgB = baseRGB[2] * f;
                if (overlay > 0) { bgR = (1 - overlay) * bgR + overlay * overlayRGB[0]; bgG = (1 - overlay) * bgG + overlay * overlayRGB[1]; bgB = (1 - overlay) * bgB + overlay * overlayRGB[2]; }

                // prepare colors and params for population
                const primaryRGB = hexToRgb(String(Settings.get('primaryColor') || '#00B3B3'));
                const secondaryRGB = hexToRgb(String(Settings.get('secondaryColor') || '#E6F6FF'));
                const tertiaryRGB = hexToRgb(String(Settings.get('tertiaryColor') || '#FFD966'));

                const primParams = { speed: (Number(Settings.get('primaryRainSpeed', 220)) / 1000), len: Number(Settings.get('primaryRainLength', 20)) / 100, spacing: Number(Settings.get('primaryRainSpacing', 18)) / 100 };
                const secParams = { speed: (Number(Settings.get('secondaryRainSpeed', 240)) / 1000), len: Number(Settings.get('secondaryRainLength', 12)) / 100, spacing: Number(Settings.get('secondaryRainSpacing', 14)) / 100 };
                const tertParams = { speed: (Number(Settings.get('tertiaryRainSpeed', 200)) / 1000), len: Number(Settings.get('tertiaryRainLength', 15)) / 100, spacing: Number(Settings.get('tertiaryRainSpacing', 18)) / 100 };

                // cap arrays
                if (primaryDrops.length > (Number(Settings.get('maxDrops', 500)) || 500)) primaryDrops.length = Number(Settings.get('maxDrops', 500)) || 500;
                if (secondaryDrops.length > (Number(Settings.get('maxDrops', 500)) || 500)) secondaryDrops.length = Number(Settings.get('maxDrops', 500)) || 500;
                if (tertiaryDrops.length > (Number(Settings.get('maxDrops', 500)) || 500)) tertiaryDrops.length = Number(Settings.get('maxDrops', 500)) || 500;

                ensurePopulation(primaryDrops, Number(Settings.get('primaryRainCount', 10) || 10), primParams, primaryRGB, Number(behavior.primAngle || Number(Settings.get('primaryRainAngle', 90))), Number(Settings.get('objectScale', 100)) / 100, Settings.get('primaryShape', 'Line'), Number(Settings.get('primaryRainBlinkPeriod', 28)));
                ensurePopulation(secondaryDrops, Number(Settings.get('secondaryRainCount', 10) || 10), secParams, secondaryRGB, Number(behavior.secAngle || Number(Settings.get('secondaryRainAngle', 60))), Number(Settings.get('objectScale', 100)) / 100, Settings.get('secondaryShape', 'Dot'), Number(Settings.get('secondaryRainBlinkPeriod', 28)));
                ensurePopulation(tertiaryDrops, Number(Settings.get('tertiaryRainCount', 10) || 10), tertParams, tertiaryRGB, Number(behavior.tertAngle || Number(Settings.get('tertiaryRainAngle', 120))), Number(Settings.get('objectScale', 100)) / 100, Settings.get('tertiaryShape', 'Star'), Number(Settings.get('tertiaryRainBlinkPeriod', 28)));

                // meteor shower logic
                if (behavior.meteorShower) {
                    const baseAngle = Math.random() * Math.PI * 2; const angleSpread = (5 * Math.PI) / 180; const speedBoost = Number(Settings.get('meteorShowerBoost', 3) || 3);
                    const primParamsBoost = { ...primParams, speed: primParams.speed * speedBoost };
                    const secParamsBoost = { ...secParams, speed: secParams.speed * speedBoost };
                    const tertParamsBoost = { ...tertParams, speed: tertParams.speed * speedBoost };
                    for (let i = 0; i < Number(Settings.get('primaryMeteorCount', 3) || 3); i++) { const offset = (Math.random() * 2 - 1) * angleSpread; const angle = rad2deg(baseAngle + offset); spawnDrop(primaryDrops, primParamsBoost, primaryRGB, angle, objectScaleFactor, 'Meteor', 0); }
                    for (let i = 0; i < Number(Settings.get('secondaryMeteorCount', 3) || 3); i++) { const offset = (Math.random() * 2 - 1) * angleSpread; const angle = rad2deg(baseAngle + offset); spawnDrop(secondaryDrops, secParamsBoost, secondaryRGB, angle, objectScaleFactor, 'Meteor', 0); }
                    for (let i = 0; i < Number(Settings.get('tertiaryMeteorCount', 3) || 3); i++) { const offset = (Math.random() * 2 - 1) * angleSpread; const angle = rad2deg(baseAngle + offset); spawnDrop(tertiaryDrops, tertParamsBoost, tertiaryRGB, angle, objectScaleFactor, 'Meteor', 0); }
                }

                updateLayer(primaryDrops, dt, Number(Settings.get('objectScale', 100)) / 100, behavior.drift);
                updateLayer(secondaryDrops, dt, Number(Settings.get('objectScale', 100)) / 100, behavior.drift);
                updateLayer(tertiaryDrops, dt, Number(Settings.get('objectScale', 100)) / 100, behavior.drift);

                // Clear & background
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, W, H);
                ctx.fillStyle = `rgb(${Math.round(bgR)}, ${Math.round(bgG)}, ${Math.round(bgB)})`;
                ctx.fillRect(0, 0, W, H);

                if (String(Settings.get('preset', 'Custom')) === 'Pulsar' || String(Settings.get('preset', 'Custom')) === 'Pulsar2') {
                    updatePulsarBursts(dt); drawPulsarBursts(); updateAndDrawLayers(dt, behavior);
                } else {
                    if (behavior.blurAmount > 0) ctx.filter = `blur(${behavior.blurAmount}px)`;
                    if (String(Settings.get('preset', 'Custom')) === 'Stars') { updateStaticStars(dt); drawStaticStars(); }
                    updateAndDrawLayers(dt, behavior);
                    if (behavior.blurAmount > 0) ctx.filter = 'none';
                }

            } catch (e) { console.error('Update loop error:', e); }
            finally { window.requestAnimationFrame(update); }
        }

        function updateAndDrawLayers(dt, behavior) {
            const objectScaleFactor = Number(Settings.get('objectScale', 100)) / 100;
            const primParams = { speed: (Number(Settings.get('primaryRainSpeed', 220)) / 1000), len: Number(Settings.get('primaryRainLength', 20)) / 100, spacing: Number(Settings.get('primaryRainSpacing', 18)) / 100 };
            const secParams = { speed: (Number(Settings.get('secondaryRainSpeed', 240)) / 1000), len: Number(Settings.get('secondaryRainLength', 12)) / 100, spacing: Number(Settings.get('secondaryRainSpacing', 14)) / 100 };
            const tertParams = { speed: (Number(Settings.get('tertiaryRainSpeed', 200)) / 1000), len: Number(Settings.get('tertiaryRainLength', 15)) / 100, spacing: Number(Settings.get('tertiaryRainSpacing', 18)) / 100 };

            const primaryRGB = hexToRgb(String(Settings.get('primaryColor') || '#00B3B3'));
            const secondaryRGB = hexToRgb(String(Settings.get('secondaryColor') || '#E6F6FF'));
            const tertiaryRGB = hexToRgb(String(Settings.get('tertiaryColor') || '#FFD966'));

            ensurePopulation(primaryDrops, Number(Settings.get('primaryRainCount', 10) || 10), primParams, primaryRGB, Number(behavior.primAngle || Number(Settings.get('primaryRainAngle', 90))), Number(Settings.get('maxDrops', 500)), objectScaleFactor, Settings.get('primaryShape', 'Line'), Number(Settings.get('primaryRainBlinkPeriod', 28)));
            ensurePopulation(secondaryDrops, Number(Settings.get('secondaryRainCount', 10) || 10), secParams, secondaryRGB, Number(behavior.secAngle || Number(Settings.get('secondaryRainAngle', 60))), Number(Settings.get('maxDrops', 500)), objectScaleFactor, Settings.get('secondaryShape', 'Dot'), Number(Settings.get('secondaryRainBlinkPeriod', 28)));
            ensurePopulation(tertiaryDrops, Number(Settings.get('tertiaryRainCount', 10) || 10), tertParams, tertiaryRGB, Number(behavior.tertAngle || Number(Settings.get('tertiaryRainAngle', 120))), Number(Settings.get('maxDrops', 500)), objectScaleFactor, Settings.get('tertiaryShape', 'Star'), Number(Settings.get('tertiaryRainBlinkPeriod', 28)));

            for (const d of primaryDrops) drawDrop(d, Settings.get('useBlink') ? blinkForDrop(d, nowSec()) : 1.0);
            for (const d of secondaryDrops) drawDrop(d, Settings.get('useBlink') ? blinkForDrop(d, nowSec()) : 1.0);
            for (const d of tertiaryDrops) drawDrop(d, Settings.get('useBlink') ? blinkForDrop(d, nowSec()) : 1.0);
        }

        // start
        window.requestAnimationFrame(update);

    </script>
</body>

</html>
